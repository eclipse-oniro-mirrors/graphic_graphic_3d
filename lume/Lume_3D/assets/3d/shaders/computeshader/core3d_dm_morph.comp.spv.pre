














#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/assets/3d/shaders/common/morph_target_structs.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"






































precision highp float;
precision highp int;





layout(constant_id = 256)const uint CORE_BACKEND_TYPE = 0;




layout(constant_id = 257)const float CORE_FLIP_NDC = 1.0;










vec2 GetFragCoordUv(vec2 fragCoord, vec2 inverseTexelSize)
{
    vec2 uv = fragCoord * inverseTexelSize;
    if(CORE_FLIP_NDC < 0.0){
        uv = vec2(uv . x, 1.0 - uv . y);
    }
    return uv;
}







#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/assets/3d/shaders/common/morph_target_structs.h"




struct MorphTargetInfoStruct {
    uvec4 target;
    vec4 weight;
};

struct MorphInputData {
    vec4 pos;

    uvec4 nortan;




};

struct MorphObjectPushConstantStruct {
    uint morphSet;
    uint vertexCount;
    uint morphTargetCount;
    uint activeTargets;
};

#line 23 "computeshader/core3d_dm_morph.comp"



layout(set = 0, binding = 0, std140)restrict readonly buffer uMorphData
{
    MorphTargetInfoStruct uObjects[];
};

layout(set = 1, binding = 0, std430)restrict readonly buffer IndexData
{
    uint indexData[];
};

layout(set = 1, binding = 1, std430)restrict readonly buffer VertexData
{
    MorphInputData data[];
};

layout(set = 2, binding = 0, std430)restrict writeonly buffer PosOut
{
    float posOut[];
};
layout(set = 2, binding = 1, std430)restrict writeonly buffer NorOut
{

    uint norOut[];



};
layout(set = 2, binding = 2, std430)restrict writeonly buffer TanOut
{

    uint tanOut[];



};

layout(push_constant, std430)uniform uPushConstant
{
    MorphObjectPushConstantStruct uObjectPushConstant;
};




vec3 UnpackMorphNormal(uvec4 nt)
{
    vec4 normal;
    normal . xy = unpackHalf2x16(nt . x);
    normal . zw = unpackHalf2x16(nt . y);
    return normal . xyz;
}

vec4 UnpackMorphTangent(uvec4 nt)
{
    vec4 tangent;
    tangent . xy = unpackHalf2x16(nt . z);
    tangent . zw = unpackHalf2x16(nt . w);
    return tangent;
}




layout(local_size_x = 64)in;
void main()
{
    const uint tid = gl_GlobalInvocationID . x;



    if(tid < uObjectPushConstant . vertexCount){
        const uint baseid = tid * 3;
        vec3 p = data[tid]. pos . xyz;


        vec3 n = UnpackMorphNormal(data[tid]. nortan);
        const vec4 fullTangent = UnpackMorphTangent(data[tid]. nortan);
        const float tangentW = fullTangent . w;
        vec3 t = fullTangent . xyz;






        for(int i = 0;i < uObjectPushConstant . activeTargets;i ++){
            const uint id = uObjects[uObjectPushConstant . morphSet + i / 4]. target[i % 4];

            const uint index = indexData[tid +(id * uObjectPushConstant . vertexCount)];
            if(index != 0xFFFFFFFF){
                const float w = uObjects[uObjectPushConstant . morphSet + i / 4]. weight[i % 4];
                p += data[index]. pos . xyz * w;

                n += UnpackMorphNormal(data[index]. nortan)* w;
                t += UnpackMorphTangent(data[index]. nortan). xyz * w;




            }
        }
        posOut[baseid + 0]= p . x;
        posOut[baseid + 1]= p . y;
        posOut[baseid + 2]= p . z;


        norOut[tid * 2]= packSnorm2x16(n . xy);
        norOut[tid * 2 + 1]= packSnorm2x16(vec2(n . z, 0.0));

        tanOut[tid * 2]= packSnorm2x16(t . xy);
        tanOut[tid * 2 + 1]= packSnorm2x16(vec2(t . z, tangentW));











    }
}
