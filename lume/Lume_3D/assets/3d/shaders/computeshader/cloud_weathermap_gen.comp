#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba32f) uniform writeonly image2D weatherMapTex;

struct PushConstantStruct {
    uint step;
};

layout(push_constant, std430) uniform uPushConstant
{
    PushConstantStruct pc;
};

// --- 2D Simplex Noise Function (snoise) ---
vec2 Mod289(vec2 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 Mod289(vec3 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
vec3 Permute(vec3 x)
{
    return Mod289(((x * 34.0) + 1.0) * x);
}

float SNoise(vec2 v)
{
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = Mod289(i);
    vec3 p = Permute(Permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m * m;
    m = m * m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
    vec3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

// --- Fractional Brownian Motion (FBM) ---
// Layers multiple octaves of noise for a more detailed result.
float Fbm(vec2 p, int octaves)
{
    float value = 0.0;
    float amplitude = 0.5;
    for (int i = 0; i < octaves; i++) {
        value += amplitude * SNoise(p);
        p *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

void main()
{
    ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(weatherMapTex);

    if (fragCoord.x >= size.x || fragCoord.y >= size.y) {
        return;
    }

    const float scale_low_freq = 1.5;
    const float scale_mid_freq = 6.0;
    const float scale_high_freq = 20.0;
    const float warp_strength = 0.5;
    const float base_coverage = 0.4;
    const vec2 wind_direction = vec2(0.05, 0.02);

    float time = float(pc.step) * 0.01;

    vec2 uv = vec2(fragCoord) / vec2(size);
    vec2 time_offset = time * wind_direction;

    vec2 coord_low = uv * scale_low_freq + time_offset;
    float noise_low = Fbm(coord_low, 3);

    vec2 coord_warp_x = uv * scale_mid_freq + time_offset + vec2(10.0, 0.0);
    vec2 coord_warp_y = uv * scale_mid_freq + time_offset + vec2(0.0, 10.0);
    vec2 warp_offset = vec2(SNoise(coord_warp_x), SNoise(coord_warp_y));

    vec2 coord_mid = uv * scale_mid_freq + time_offset + (warp_offset * warp_strength);
    float noise_mid = Fbm(coord_mid, 4);

    vec2 coord_high = uv * scale_high_freq + time_offset;
    float noise_high = Fbm(coord_high, 5);

    float combined_noise = noise_low * 0.6 + noise_mid * 0.3 + noise_high * 0.1;
    float remapped_noise = combined_noise * 0.5 + 0.5;

    float coverage = clamp(remapped_noise + base_coverage - 0.5, 0.0, 1.0);
    coverage = smoothstep(0.4, 0.6, coverage);

    float density = (noise_mid * 0.5 + 0.5) * coverage;
    density = smoothstep(0.2, 0.8, density);

    float precipitation = smoothstep(0.8, 0.95, density) * smoothstep(0.7, 0.9, coverage);

    float top_offset = (noise_high * 0.5 + 0.5) * coverage;

    // R: Coverage, G: Density, B: Precipitation, A: Turbulence/Top Offset
    vec4 weather_data = vec4(coverage, density, precipitation, top_offset);
    imageStore(weatherMapTex, fragCoord, weather_data);
}
