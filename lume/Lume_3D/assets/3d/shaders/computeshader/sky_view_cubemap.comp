#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

#include "common/atmosphere_lut.h"
#include "render/shaders/common/render_post_process_structs_common.h"

layout(set = 0, binding = 0, r11f_g11f_b10f) uniform writeonly image2DArray skyViewCubemap;
layout(set = 0, binding = 1) uniform sampler2D skyViewLut;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct PushConstantStruct {
    vec4 sunDir;
    vec4 cameraPosBrightness;
};

layout(push_constant, std430) uniform uPostProcessPushConstant
{
    PushConstantStruct uPc;
};

vec3 GetCubemapDirection(vec2 uv, uint face) {
    vec2 pos = uv * 2.0 - 1.0;
    
    vec3 dir;
    switch(face) {
        case 0: dir = vec3( 1.0,   -pos.y, -pos.x); break; // +X
        case 1: dir = vec3(-1.0,   -pos.y,  pos.x); break; // -X
        case 2: dir = vec3( pos.x,  1.0,    pos.y); break; // +Y
        case 3: dir = vec3( pos.x, -1.0,   -pos.y); break; // -Y
        case 4: dir = vec3( pos.x, -pos.y,  1.0  ); break; // +Z
        case 5: dir = vec3(-pos.x, -pos.y, -1.0  ); break; // -Z
    }
    return normalize(dir);
}

vec3 GetValFromSkyLUT(vec3 rayDir, vec3 sunDir, vec3 viewPos) {
    float height = length(viewPos);
    vec3 up = viewPos / height;
    
    float horizonAngle = Safeacos(sqrt(height * height - GROUND_RADIUS_KM * GROUND_RADIUS_KM) / height);
    float altitudeAngle = -(horizonAngle - acos(dot(rayDir, up)));
    
    float azimuthAngle = 0.0;
    if (abs(altitudeAngle) <= (0.5 * M_PI - 0.0001)) {
        vec3 right = cross(sunDir, up);
        vec3 forward = cross(up, right);
        
        vec3 projectedDir = normalize(rayDir - up * dot(rayDir, up));
        float sinTheta = dot(projectedDir, right);
        float cosTheta = dot(projectedDir, forward);
        azimuthAngle = atan(sinTheta, cosTheta);
        
        if (azimuthAngle < 0.0) {
            azimuthAngle += 2.0 * M_PI;
        }
    }
    
    float v = 0.5 + 0.5 * sign(altitudeAngle) * sqrt(abs(altitudeAngle) * 2.0 / M_PI);
    vec2 uv = vec2(azimuthAngle / (2.0 * M_PI), v);
    
    return texture(skyViewLut, uv).rgb;
}

void main() {
    ivec3 globalID = ivec3(gl_GlobalInvocationID);
    ivec3 cubemapSize = imageSize(skyViewCubemap);
    
    if (any(greaterThanEqual(globalID.xy, cubemapSize.xy))) {
        return;
    }
   
    uint face = globalID.z;
    if (face > 5) {
        return;
    }
    
    vec2 uv = (vec2(globalID.xy) + 0.5) / vec2(cubemapSize.xy);
    vec3 worldDir = GetCubemapDirection(uv, face);
    
    vec3 sunDir = normalize(uPc.sunDir.xyz);
    vec3 cameraPos = uPc.cameraPosBrightness.xyz;
    float actualHeight = length(cameraPos);
    float scaledHeight = GROUND_RADIUS_KM + (actualHeight * CAMERA_HEIGHT_SCALE);
    vec3 viewPos = vec3(0.0, -scaledHeight, 0.0);
    
    float sunElevation = uPc.sunDir.w;
    
    vec3 skyColor = GetValFromSkyLUT(worldDir, sunDir, viewPos);
    
    imageStore(skyViewCubemap, ivec3(globalID.xy, face), vec4(skyColor, 1.0));
}