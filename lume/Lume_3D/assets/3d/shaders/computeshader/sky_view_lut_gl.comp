#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

// Based on Buffer C of https://www.shadertoy.com/view/slSXRW

#include "render/shaders/common/render_post_process_structs_common.h"

layout(set = 0, binding = 0, rgba16f) uniform image2D skyViewOut;
layout(set = 0, binding = 1) uniform sampler2D transmittanceLut;
layout(set = 0, binding = 2) uniform sampler2D multipleScatteringLut;

// Define after the images
#include "common/sky_view_common.h"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct PushConstantLocalStruct {
    vec4 cameraPosSunElevation; // .xyz: camera position, .w: sun elevation
    vec4 rayleighScatteringBase; // .w = mieAbsorptionBase
    vec4 ozoneAbsorptionBase; // .w = mieScatteringBase
    vec4 groundColor; // .w = skyViewBrightness
};

layout(push_constant, std430) uniform uPostProcessPushConstant
{
    PushConstantLocalStruct uPc;
};

void main() {
    const ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 imageDim = imageSize(skyViewOut);

    AtmosphericConfig atmosphericConfig;
    atmosphericConfig.rayleighScatteringBase = uPc.rayleighScatteringBase.xyz;
    atmosphericConfig.mieAbsorptionBase = uPc.rayleighScatteringBase.w;
    atmosphericConfig.ozoneAbsorptionBase = uPc.ozoneAbsorptionBase.xyz;
    atmosphericConfig.mieScatteringBase = uPc.ozoneAbsorptionBase.w;
    atmosphericConfig.groundColor = uPc.groundColor.xyz;
    atmosphericConfig.skyViewBrightness = uPc.groundColor.w;

    if (any(greaterThanEqual(uv, imageDim))) {
        return;
    }
    float u = clamp(float(uv.x + 0.5), 0.0, float(imageDim.x - 1)) / float(imageDim.x);
    float v = clamp(float(uv.y + 0.5), 0.0, float(imageDim.y - 1)) / float(imageDim.y);

    v = 1.0 - v;

    float azimuthAngle = (u - 0.5)*2.0*M_PI;
    float adjV;
    if (v < 0.5) {
        float coord = 1.0 - 2.0*v;
        adjV = -coord*coord;
    } else {
        float coord = v*2.0 - 1.0;
        adjV = coord*coord;
    }
    
    vec3 actualCameraPos = uPc.cameraPosSunElevation.xyz;
    float actualHeight = length(actualCameraPos);
    float scaledHeight = GROUND_RADIUS_KM + (actualHeight * CAMERA_HEIGHT_SCALE);
    // Flip y to correctly orient the LUT
    vec3 viewPos = vec3(0.0, -scaledHeight, 0.0);

    float height = length(viewPos);
    vec3 up = viewPos / height;
    float horizonParam = (height * height - GROUND_RADIUS_KM * GROUND_RADIUS_KM);
    float horizonAngle = Safeacos(sqrt(horizonParam) / height) - 0.5*M_PI;
    float altitudeAngle = adjV*0.5*M_PI - horizonAngle;
    
    float cosAltitude = cos(altitudeAngle);
    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));
    
    float sunElevation = uPc.cameraPosSunElevation.w;
    // Create sun direction vector in the Y-Z plane based on the elevation angle
    vec3 sunDir = vec3(0.0, sin(sunElevation), -cos(sunElevation));
    
    // Flip the sun direction to match the sky environment shader
    vec3 lum = RaymarchScattering(viewPos, rayDir, -sunDir, NUM_SCATTERING_STEPS, atmosphericConfig);
    
    imageStore(skyViewOut, uv, vec4(lum, 1.0));
}