#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

// Based on Buffer A of https://www.shadertoy.com/view/slSXRW

#include "common/atmosphere_lut.h"

layout(set = 0, binding = 0, r11f_g11f_b10f) uniform image2D transmittanceOut;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct PushConstantLocalStruct {
    vec4 rayleighScatteringBase; // .w = mieAbsorptionBase
    vec4 ozoneAbsorptionBase; // .w = mieScatteringBase
};

layout(push_constant, std430) uniform uPostProcessPushConstant
{
    PushConstantLocalStruct uPc;
};

void main() {
    const ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 imageDim = imageSize(transmittanceOut);

    AtmosphericConfig atmosphericConfig;
    atmosphericConfig.rayleighScatteringBase = uPc.rayleighScatteringBase.xyz;
    atmosphericConfig.mieAbsorptionBase = uPc.rayleighScatteringBase.w;
    atmosphericConfig.ozoneAbsorptionBase = uPc.ozoneAbsorptionBase.xyz;
    atmosphericConfig.mieScatteringBase = uPc.ozoneAbsorptionBase.w;
    
    if (any(greaterThanEqual(uv, imageDim))) {
        return;
    }
    
    vec2 normalizedUV = vec2(uv.x + 0.5, uv.y + 0.5) / vec2(imageDim);
    
    float r, mu;
    GetRMuFromTransmittanceTextureUv(normalizedUV, r, mu);
    
    vec3 transmittance = ComputeTransmittanceToTopAtmosphereBoundary(r, mu, atmosphericConfig);
    
    imageStore(transmittanceOut, uv, vec4(transmittance, 1.0));
}

