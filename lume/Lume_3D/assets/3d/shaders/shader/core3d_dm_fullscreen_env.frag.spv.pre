














#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_indirect_lighting_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"






































precision highp float;
precision highp int;





layout(constant_id = 256)const uint CORE_BACKEND_TYPE = 0;




layout(constant_id = 257)const float CORE_FLIP_NDC = 1.0;










vec2 GetFragCoordUv(vec2 fragCoord, vec2 inverseTexelSize)
{
    vec2 uv = fragCoord * inverseTexelSize;
    if(CORE_FLIP_NDC < 0.0){
        uv = vec2(uv . x, 1.0 - uv . y);
    }
    return uv;
}







#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_packing_common.h"





















uvec2 PackVec4Half2x16(const vec4 up)
{
    uvec2 packed;
    packed . x = packHalf2x16(up . xy);
    packed . y = packHalf2x16(up . zw);
    return packed;
}

vec4 UnpackVec4Half2x16(const uvec2 packed)
{
    vec4 up;
    up . xy = unpackHalf2x16(packed . x);
    up . zw = unpackHalf2x16(packed . y);
    return up;
}

uvec4 Pack2Vec4Half2x16(const vec4 up0, const vec4 up1)
{
    uvec4 packed;
    packed . x = packHalf2x16(up0 . xy);
    packed . y = packHalf2x16(up0 . zw);
    packed . z = packHalf2x16(up1 . xy);
    packed . w = packHalf2x16(up1 . zw);
    return packed;
}

void UnpackVec42Half2x16(const uvec4 packed, inout vec4 up0, inout vec4 up1)
{
    up0 . xy = unpackHalf2x16(packed . x);
    up0 . zw = unpackHalf2x16(packed . y);
    up1 . xy = unpackHalf2x16(packed . z);
    up1 . zw = unpackHalf2x16(packed . w);
}




#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"





















































































































































































































struct DefaultMaterialSingleMeshStruct {


    mat4 world;
    mat4 normalWorld;
    mat4 prevWorld;


    uvec4 indices;

    uvec4 layers;

    uvec4 customData[2];
};

struct DefaultMaterialMeshStruct {
    DefaultMaterialSingleMeshStruct mesh[64];
};

struct DefaultMaterialSingleMaterialStruct {
    vec4 factors[15];
    uvec4 indices;
};

struct DefaultMaterialMaterialStruct {
    DefaultMaterialSingleMaterialStruct material[64];
};

struct DefaultMaterialTransformSingleMaterialStruct {
    uvec4 packed[15];
    uvec4 indices;
};

struct DefaultMaterialTransformMaterialStruct {
    DefaultMaterialTransformSingleMaterialStruct material[64];
};

struct DefaultMaterialSingleUserMaterialStruct {
    uvec4 userData[16u];
};

struct DefaultMaterialUserMaterialStruct {
    DefaultMaterialSingleUserMaterialStruct material[64];
};

struct DefaultMaterialSingleLightStruct {
    vec4 pos;

    vec4 dir;

    vec4 color;

    vec4 spotLightParams;

    vec4 shadowFactors;

    vec4 additionalFactor;


    uvec4 flags;

    uvec4 indices;
};

struct DefaultMaterialLightStruct {
    uint directionalLightBeginIndex;
    uint directionalLightCount;

    uint pointLightBeginIndex;
    uint pointLightCount;

    uint spotLightBeginIndex;
    uint spotLightCount;

    uint pad0;
    uint pad1;

    uvec4 clusterSizes;
    vec4 clusterFactors;

    vec4 atlasSizeInvSize;
    vec4 additionalFactors;

    DefaultMaterialSingleLightStruct lights[64];
};

struct DefaultMaterialSkinStruct {

    mat4 jointMatrices[256u];
};


struct DefaultMaterialGeneralDataStruct {

    uvec4 indices;

    vec4 viewportSizeInvViewportSize;

    vec4 sceneTimingData;
};


struct DefaultMaterialEnvironmentStruct {

    vec4 indirectSpecularColorFactor;

    vec4 indirectDiffuseColorFactor;

    vec4 envMapColorFactor;

    vec4 values;

    vec4 blendFactor;


    mat4 envRotation;


    uvec4 indices;


    vec4 shIndirectCoefficients[9];


    vec4 pad0;
};

struct DefaultMaterialFogStruct {

    uvec4 indices;


    vec4 firstLayer;

    vec4 secondLayer;


    vec4 baseFactors;

    vec4 inscatteringColor;

    vec4 envMapFactor;


    vec4 additionalFactor;
};


struct DefaultCameraMatrixStruct {
    mat4 view;
    mat4 proj;
    mat4 viewProj;

    mat4 viewInv;
    mat4 projInv;
    mat4 viewProjInv;

    mat4 viewPrevFrame;
    mat4 projPrevFrame;
    mat4 viewProjPrevFrame;

    mat4 shadowViewProj;
    mat4 shadowViewProjInv;


    vec4 jitter;
    vec4 jitterPrevFrame;


    uvec4 indices;

    uvec4 multiViewIndices;

    vec4 frustumPlanes[6];


    uvec4 counts;

    uvec4 pad0;
    mat4 matPad0;
    mat4 matPad1;
};





struct DefaultMaterialUnpackedSceneTimingStruct {

    float sceneDeltaTime;

    float tickDeltaTime;

    float tickTotalTime;

    uint frameIndex;
};

struct DefaultMaterialUnpackedPostProcessStruct {
    float tonemapExposure;
    float vignetteCoeff;
    float vignettePower;
};

uint GetPackFlatIndices(const uint cameraIdx, const uint instanceIdx)
{
    return((instanceIdx << 16)|(cameraIdx & 0xffff));
}

void GetUnpackFlatIndices(in uint indices, out uint cameraIdx, out uint instanceIdx)
{
    cameraIdx = indices & 0xffff;
    instanceIdx = indices >> 16;
}

uint GetUnpackFlatIndicesInstanceIdx(in uint indices)
{
    return(indices >> 16);
}

uint GetUnpackFlatIndicesCameraIdx(in uint indices)
{
    return(indices & 0xffff);
}

uint GetUnpackCameraIndex(const DefaultMaterialGeneralDataStruct dmgds)
{
    return dmgds . indices . x;
}

DefaultMaterialUnpackedSceneTimingStruct GetUnpackSceneTiming(const DefaultMaterialGeneralDataStruct dmgds)
{
    DefaultMaterialUnpackedSceneTimingStruct dm;
    dm . sceneDeltaTime = dmgds . sceneTimingData . x;
    dm . tickDeltaTime = dmgds . sceneTimingData . y;
    dm . tickTotalTime = dmgds . sceneTimingData . z;
    dm . frameIndex = floatBitsToUint(dmgds . sceneTimingData . w);
    return dm;
}

vec4 GetUnpackViewport(const DefaultMaterialGeneralDataStruct dmgds)
{
    return dmgds . viewportSizeInvViewportSize;
}



struct DefaultMaterialUnpackedTexTransformStruct {
    vec4 rotateScale;
    vec2 translate;
};

DefaultMaterialUnpackedTexTransformStruct GetUnpackTextureTransform(const uvec4 packedTexTransform)
{
    DefaultMaterialUnpackedTexTransformStruct dm;
    dm . rotateScale = UnpackVec4Half2x16(packedTexTransform . xy);
    dm . translate = UnpackVec4Half2x16(packedTexTransform . zw). xy;
    return dm;
}











































































































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_indirect_lighting_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_indirect_lighting_common.h"













vec3 unpackEnvMap(vec4 envColorRgbd)
{
    return envColorRgbd . xyz *(1.0 / envColorRgbd . a);
}


vec3 unpackIblRadiance(vec4 envColorRgbd)
{
    return envColorRgbd . xyz *(1.0 / envColorRgbd . a);
}


vec3 unpackIblIrradianceSH(vec3 n, vec4 sh[9])
{

    return max(vec3(0.0), sh[0]. xyz

                              + sh[1]. xyz * n . y + sh[2]. xyz * n . z + sh[3]. xyz * n . x

                              + sh[4]. xyz *(n . x * n . y)+ sh[5]. xyz *(n . z * n . y)+
                              sh[6]. xyz *((3.0 * n . z * n . z)- 1.0)+ sh[7]. xyz *(n . x * n . z)+
                              sh[8]. xyz *(n . x * n . x - n . y * n . y));
}



vec3 EnvBRDFApprox(vec3 f0, float roughness, float NoV)
{
    const vec4 c0 = vec4(- 1.0, - 0.0275, - 0.572, 0.022);
    const vec4 c1 = vec4(1.0, 0.0425, 1.04, - 0.04);
    vec4 r = roughness * c0 + c1;
    float a004 = min(r . x * r . x, exp2(- 9.28 * NoV))* r . x + r . y;
    vec2 ab = vec2(- 1.04, 1.04)* a004 + r . zw;


    const float f90 = clamp(50.0 * max(f0 . x, max(f0 . y, f0 . z)), 0.0, 1.0);
    return f0 * ab . x + ab . y * f90;
}



float EnvBRDFApproxNonmetal(float Roughness, float NoV)
{

    const vec2 c0 = { - 1, - 0.0275 };
    const vec2 c1 = { 1, 0.0425 };
    vec2 r = Roughness * c0 + c1;
    return min(r . x * r . x, exp2(- 9.28 * NoV))* r . x + r . y;
}




#line 23 "shader/core3d_dm_fullscreen_env.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"























































































































































































































































































































































































































































































































































































































































#line 24 "shader/core3d_dm_fullscreen_env.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_target_packing_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"























































































































































































































































































































































































































































































































































































































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_target_packing_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_target_packing_common.h"





vec2 OctWrap(in vec2 v)
{
    return(1.0 - abs(v . yx))* vec2((v . x >= 0.0)? 1.0 : - 1.0,(v . y >= 0.0)? 1.0 : - 1.0);
}
vec2 NormalOctEncode(in vec3 normal)
{
    vec3 n = normal;
    n /=(abs(n . x)+ abs(n . y)+ abs(n . z));
    n . xy = n . z >= 0.0 ? n . xy : OctWrap(n . xy);
    n . xy = n . xy * 0.5 + 0.5;
    return n . xy;
}
vec3 NormalOctDecode(in vec2 f)
{
    f = f * 2.0 - 1.0;
    vec3 n = vec3(f . x, f . y, 1.0 - abs(f . x)- abs(f . y));
    float t = clamp(- n . z, 0.0, 1.0);
    n . xy += vec2((n . x >= 0.0)? - t : t,(n . y >= 0.0)? - t : t);
    return normalize(n);
}








uint GetDeferredMaterialFlagsFromMaterialFlags(uint materialFlags)
{
    uint mat = 0;
    mat |=((materialFlags &(1 << 0))==(1 << 0))
               ?(1 << 0)
               : 0;
    mat |=((materialFlags &(1 << 10))==(1 << 10))
               ?(1 << 1)
               : 0;
    mat |=((materialFlags &(1 << 11))==(1 << 11))
               ?(1 << 2)
               : 0;
    return mat;
}

uint GetMaterialFlagsFromDeferredMaterialFlags(uint materialFlags)
{
    uint mat = 0;
    mat |=((materialFlags &(1 << 0))==(1 << 0))
               ?(1 << 0)
               : 0;
    mat |=
        ((materialFlags &(1 << 1))==(1 << 1))
            ?(1 << 10)
            : 0;
    mat |=
        ((materialFlags &(1 << 2))==(1 << 2))
            ?(1 << 11)
            : 0;
    return mat;
}



vec4 GetPackColor(in vec4 col)
{
    return col;
}

vec4 GetPackBaseColorWithAo(in vec3 col, in float ao)
{
    return vec4(col . xyz, ao);
}

vec3 GetPackNormal(in vec3 normal)
{

    return vec3(NormalOctEncode(normal), 0.0);



}

vec4 GetPackMaterialWithFlags(in vec4 material, in uint materialType, in uint materialFlags)
{
    vec4 packed = material;
    const uint mf = GetDeferredMaterialFlagsFromMaterialFlags(materialFlags);
    const uint mat =(mf << 3)| materialType;
    packed . r = float(mat)*(1.0 / 255.0);
    if(materialType == 0){

        packed . a = clamp(packed . a * 10.0, 0.0, 1.0);
    }
    return packed;
}

vec2 GetPackVelocity(in vec2 velocity)
{
    return velocity;
}

vec4 GetPackVelocityAndNormal(in vec2 velocity, in vec3 normal)
{
    return vec4(velocity, NormalOctEncode(normal));
}

vec4 GetPackPbrColor(in vec3 color, in mediump float alpha)
{

    return vec4(clamp(color . rgb, 0.0, 64512.0)* alpha, alpha);
}



float GetUnpackDepthBuffer(in float depthSample)
{
    return depthSample;
}

void GetUnpackBaseColorWithAo(in vec4 col, out vec3 color, out float ao)
{
    color . rgb = col . rgb;
    ao = col . a;
}

vec3 GetUnpackNormal(in vec3 normal)
{

    return NormalOctDecode(normal . xy);



}

void GetUnpackMaterialWithFlags(in vec4 inMat, out vec4 material, out uint materialType, out uint materialFlags)
{
    material = inMat;
    const uint mat = uint(round(material . r * 255.0));
    materialType = mat & 7;
    materialFlags = GetMaterialFlagsFromDeferredMaterialFlags(mat >> 3);
    if(materialType == 0){

        material . a = material . a *(1.0 / 10.0);
    }
}

vec2 GetUnpackVelocity(in vec2 velocity)
{
    return velocity;
}

void GetUnpackVelocityAndNormal(in vec4 packed, out vec2 velocity, out vec3 normal)
{
    velocity = packed . xy;
    normal = NormalOctDecode(packed . zw);
}






#line 25 "shader/core3d_dm_fullscreen_env.frag"



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_env_frag_layout_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"























































































































































































































































































































































































































































































































































































































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_env_frag_layout_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_env_frag_layout_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"






















































struct GlobalPostProcessStruct {

    uvec4 flags;

    vec4 renderTimings;


    vec4 factors[14];


    vec4 userFactors[16];
};




struct LocalPostProcessStruct {

    vec4 factors[16];
};

struct LocalPostProcessPushConstantStruct {

    vec4 viewportSizeInvSize;

    vec4 factor;
};

struct PostProcessTonemapStruct {
    vec4 texSizeInvTexSize;

    uvec4 flags;

    vec4 tonemap;
    vec4 vignette;
    vec4 colorFringe;
    vec4 dither;

    vec4 bloomParameters;
};


#line 22 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_env_frag_layout_common.h"






layout(set = 0, binding = 0, std140)uniform uCameraMatrices
{
    DefaultCameraMatrixStruct uCameras[16];
};
layout(set = 0, binding = 1, std140)uniform uGeneralStructData
{
    DefaultMaterialGeneralDataStruct uGeneralData;
};
layout(set = 0, binding = 2, std140)uniform uEnvironmentStructData
{
    DefaultMaterialEnvironmentStruct uEnvironmentData;
};
layout(set = 0, binding = 3, std140)uniform uFogStructData
{
    DefaultMaterialFogStruct uFogData;
};
layout(set = 0, binding = 4, std140)uniform uPostProcessStructData
{
    GlobalPostProcessStruct uPostProcessData;
};

layout(set = 1, binding = 0)uniform sampler2D uImgSampler;
layout(set = 1, binding = 1)uniform samplerCube uImgCubeSampler;

layout(constant_id = 0)const uint CORE_DEFAULT_ENV_TYPE = 0;
layout(constant_id = 3)const uint CORE_POST_PROCESS_FLAGS = 0;
layout(constant_id = 4)const uint CORE_CAMERA_FLAGS = 0;






#line 29 "shader/core3d_dm_fullscreen_env.frag"

#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_env_common.h"




















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_fog_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"























































































































































































































































































































































































































































































































































































































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_fog_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_fog_common.h"



struct FogLayer {
    float density;
    float fallOff;
    float offset;
};

float CalculateLineIntegral(in FogLayer layer, in float rayDirY, in float rayOrigY)
{
    const float epsilon = 0.005;

    const float exponent = max(- 127.0f, layer . fallOff *(rayOrigY - layer . offset));

    const float falloff = max(- 127.0f, layer . fallOff * rayDirY);

    const float lineIntegral =(1.0f - exp2(- falloff))/ falloff;
    const float lineIntegralTaylor = log(2.0)-(0.5 *(log(2.0)* log(2.0)))* falloff;

    return layer . density * exp2(- exponent)*(abs(falloff)> epsilon ? lineIntegral : lineIntegralTaylor);
}

void InplaceFogBlock(in uint flags, in vec3 worldPos, in vec3 camWorldPos, in vec4 inCol, out vec3 outCol)
{
    outCol = inCol . rgb;
    if((flags &(1 << 0))==(1 << 0)){
        const vec3 cameraToPointVector = worldPos - camWorldPos;

        float cameraToPointY = cameraToPointVector . y;
        float cameraY = camWorldPos . y;

        const float cameraToPointLengthSqr = dot(cameraToPointVector, cameraToPointVector);
        const float cameraToPointLengthInv = inversesqrt(cameraToPointLengthSqr);
        float worldDistanceToCamera = cameraToPointLengthSqr * cameraToPointLengthInv;

        const float minDistance = uFogData . baseFactors . x;
        if(minDistance > 0){

            const float minIntersectionT = minDistance * cameraToPointLengthInv;
            const float cameraToMinIntersectionY = minIntersectionT * cameraToPointY;

            cameraToPointY = cameraToPointY - cameraToMinIntersectionY;
            cameraY = cameraY + cameraToMinIntersectionY;
            worldDistanceToCamera =(1.0f - minIntersectionT)* worldDistanceToCamera;
        }

        const FogLayer L1 = FogLayer(uFogData . firstLayer . x, uFogData . firstLayer . y, uFogData . firstLayer . z);
        const float layer1Integral = CalculateLineIntegral(L1, cameraToPointY, cameraY);

        const FogLayer L2 = FogLayer(uFogData . secondLayer . x, uFogData . secondLayer . y, uFogData . secondLayer . z);
        const float layer2Integral = CalculateLineIntegral(L2, cameraToPointY, cameraY);

        const float exponentialHeightLineIntegral =(layer1Integral + layer2Integral)* worldDistanceToCamera;

        const float maxOpacity = uFogData . baseFactors . z;
        float expFogFactor = min(1.0 - clamp(exp2(- exponentialHeightLineIntegral), 0.0, 1.0), maxOpacity);

        const float cutOffDistance = uFogData . baseFactors . y;
        if(cutOffDistance > 0 && worldDistanceToCamera > cutOffDistance){
            expFogFactor = 0;
        }

        const vec4 inscatteringColor = uFogData . inscatteringColor;
        const vec4 envMapColor = uFogData . envMapFactor;
        const vec3 fogColor = inscatteringColor . rgb * inscatteringColor . a + envMapColor . rgb * envMapColor . a;
        const vec3 baseColor = inCol . rgb;

        outCol . rgb = mix(baseColor, fogColor, expFogFactor);
    }
}






#line 22 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_env_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_structures_common.h"























































































































































































































































































































































































































































































































































































































































#line 23 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_env_common.h"










void EnvironmentTypeBlock(out uint environmentType)
{
    environmentType = CORE_DEFAULT_ENV_TYPE;
}









void InplaceEnvironmentBlock(
    in uint environmentType, in uint cameraIdx, in vec2 uv, in samplerCube cubeMap, in sampler2D texMap, out vec4 color)
{
    color = vec4(0.0, 0.0, 0.0, 1.0);
                mediump const float lodLevel = uEnvironmentData . values . y;




    mat4 viewProjInv = uCameras[cameraIdx]. viewInv;
    viewProjInv[3]= vec4(0.0, 0.0, 0.0, 1.0);
    viewProjInv = viewProjInv * uCameras[cameraIdx]. projInv;

    vec4 farPlane = viewProjInv * vec4(uv . x, uv . y, 1.0, 1.0);
    farPlane . xyz = farPlane . xyz / farPlane . w;

    if((environmentType == 2)||
        (environmentType == 3)){
        vec4 nearPlane = viewProjInv * vec4(uv . x, uv . y, 0.0, 1.0);
        nearPlane . xyz = nearPlane . xyz / nearPlane . w;

        const vec3 worldView = mat3(uEnvironmentData . envRotation)* normalize(farPlane . xyz - nearPlane . xyz);

        if(environmentType == 2){
            color . rgb = unpackEnvMap(textureLod(cubeMap, worldView, lodLevel));
        } else {
            const vec2 texCoord = vec2(atan(worldView . z, worldView . x)+ 3.1415926535897932384626433832795, acos(worldView . y))/
                                  vec2(2.0 * 3.1415926535897932384626433832795, 3.1415926535897932384626433832795);
            color = textureLod(texMap, texCoord, lodLevel);
        }
    } else if(environmentType == 1){
        const vec2 texCoord =(uv + vec2(1.0))* 0.5;
        color = textureLod(texMap, texCoord, lodLevel);
    }

    color . xyz *= uEnvironmentData . envMapColorFactor . xyz;


    const vec3 camPos = uCameras[cameraIdx]. viewInv[3]. xyz;
    vec3 fogColor = color . rgb;
    InplaceFogBlock(CORE_CAMERA_FLAGS, farPlane . xyz, camPos, color, fogColor);
    color . rgb = fogColor . rgb;
}






#line 31 "shader/core3d_dm_fullscreen_env.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_post_process.h"



















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_blocks.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"






















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 24 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"




float CalcLuma(const vec3 color)
{

    return 0.299 * color . r + 0.587 * color . g + 0.114 * color . b;
}




float CalcLumaFxaa(const vec3 color)
{

    return color . g *(0.587 / 0.299)+ color . r;
}




float LumaWeight(const float luma)
{
    return(1.0 /(1.0 + luma));
}




vec3 TonemapLuma(const vec3 color, const float luma, const float range)
{
    return color /(1.0 + luma / range);
}




vec3 TonemapLumaInv(const vec3 color, const float luma, const float range)
{
    return color /(1.0 - luma / range);
}





vec3 SrgbToLinear(const vec3 srgb)
{
    const float mlow = 1.0f / 12.92f;
    const float mhigh = 1.0f / 1.055f;

    const vec3 high = pow((srgb + 0.055f)* mhigh, vec3(2.4f));
    const vec3 low = srgb * mlow;
    const bvec3 cutoff = lessThan(srgb, vec3(0.04045f));
    return mix(high, low, cutoff);
}





vec3 LinearToSrgb(const vec3 linear)
{
    const float mlow = 12.92f;
    const float mhigh = 1.055f;

    const vec3 high = pow(linear, vec3(0.416f))* mhigh - 0.055f;
    const vec3 low = linear * mlow;
    const bvec3 cutoff = lessThan(linear, vec3(0.0031308f));
    return mix(high, low, cutoff);
}





vec3 rgbToYCoCg(const vec3 rgb)
{
    const float y = dot(rgb, vec3(0.25, 0.5, 0.25));
    const float co = dot(rgb, vec3(0.5, 0.0, - 0.5));
    const float cg = dot(rgb, vec3(- 0.25, 0.5, - 0.25));
    return vec3(y, co, cg);
}





vec3 yCoCgToRgb(const vec3 ycocg)
{
    const float y = ycocg . r;
    const float co = ycocg . g;
    const float cg = ycocg . b;
    return vec3(y + co - cg, y + cg, y - co - cg);
}


#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_blocks.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"



















































































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_blocks.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_tonemap_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"



















































































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"






float getVignetteCoeff(const vec2 uv, mediump const float coeff, mediump const float power)
{
    vec2 uvVal = uv . xy *(vec2(1.0)- uv . yx);
    float vignette = uvVal . x * uvVal . y * coeff;
    vignette = pow(vignette, power);
    return clamp(vignette, 0.0, 1.0);
}




float getChromaCoeff(const vec2 uv, mediump const float chromaCoefficient)
{

    vec2 distUv =(uv - 0.5)* 2.0;
    return dot(distUv, distUv)* chromaCoefficient;
}




float RandomDither(vec2 st)
{
    return fract(sin(dot(st . xy, vec2(12.9898, 78.233)))* 43758.5453);
}




#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_tonemap_common.h"





vec3 TonemapAces(vec3 x)
{
    const float a = 2.51f;
    const float b = 0.03f;
    const float c = 2.43f;
    const float d = 0.59f;
    const float e = 0.14f;
    return(x *(a * x + b))/(x *(c * x + d)+ e);
}





vec3 TonemapAcesFilmRec2020(vec3 x)
{
    float a = 15.8f;
    float b = 2.12f;
    float c = 1.2f;
    float d = 5.92f;
    float e = 1.9f;
    return(x *(a * x + b))/(x *(c * x + d)+ e);
}





float TonemapFilmic(float x)
{
    const float a = 0.15f;
    const float b = 0.50f;
    const float c = 0.10f;
    const float d = 0.20f;
    const float e = 0.02f;
    const float f = 0.30f;
    return((x *(a * x + c * b)+ d * e)/(x *(a * x + b)+ d * f))- e / f;
}
vec3 TonemapFilmic(vec3 x)
{
    const float a = 0.15f;
    const float b = 0.50f;
    const float c = 0.10f;
    const float d = 0.20f;
    const float e = 0.02f;
    const float f = 0.30f;
    const float w = 11.2f;
    const vec3 curr =((x *(a * x + c * b)+ d * e)/(x *(a * x + b)+ d * f))- e / f;
    const float whiteScale = 1.0 / TonemapFilmic(w);
    return curr * vec3(whiteScale);
}


#line 22 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_blocks.h"






void PostProcessTonemapBlock(in uint postProcessFlags, in vec4 tonemapFactor, in vec3 inCol, out vec3 outCol)
{
    outCol = inCol;
    if((postProcessFlags &(1 << 0))==(1 << 0)){
        const float exposure = tonemapFactor . x;
        const vec3 x = outCol * exposure;
        const uint tonemapType = uint(tonemapFactor . w);
        if(tonemapType == 0){
            outCol = TonemapAces(x);
        } else if(tonemapType == 1){
            outCol = TonemapAcesFilmRec2020(x);
        } else if(tonemapType == 2){
            const float exposureEstimate = 6.0f;
            outCol = TonemapFilmic(x * exposureEstimate);
        }
    }
}




void PostProcessVignetteBlock(
    in uint postProcessFlags, in vec4 vignetteFactor, in vec2 uv, in vec3 inCol, out vec3 outCol)
{
    outCol = inCol;
    if((postProcessFlags &(1 << 1))==(1 << 1)){
        const vec2 uvVal = uv . xy *(vec2(1.0)- uv . yx);
                    mediump float vignette = uvVal . x * uvVal . y * vignetteFactor . x * 40.0;
        vignette = clamp(pow(vignette, vignetteFactor . y), 0.0, 1.0);
        outCol . rgb *= vignette;
    }
}




void PostProcessColorFringeBlock(in uint postProcessFlags, in vec4 chromaFactor, in vec2 uv, in vec2 uvSize,
    in sampler2D imgSampler, in vec3 inCol, out vec3 outCol)
{
    outCol = inCol;
    if((postProcessFlags &(1 << 4))==
                                                   (1 << 4)){

        const vec2 distUv =(uv - 0.5)* 2.0;
        const mediump float chroma = dot(distUv, distUv)* chromaFactor . y * chromaFactor . x;

        const vec2 uvDistToImageCenter = chroma * uvSize;
        const mediump float chromaRed =
            textureLod(imgSampler, uv - vec2(uvDistToImageCenter . x, uvDistToImageCenter . y), 0). x;
        const mediump float chromaBlue =
            textureLod(imgSampler, uv + vec2(uvDistToImageCenter . x, uvDistToImageCenter . y), 0). z;

        outCol . r = chromaRed;
        outCol . b = chromaBlue;
    }
}




void PostProcessDitherBlock(in uint postProcessFlags, in vec4 ditherFactor, in vec2 uv, in vec3 inCol, out vec3 outCol)
{
    outCol = inCol;
    if((postProcessFlags &(1 << 2))==(1 << 2)){
        const vec2 random01Range = vec2(uv . x * ditherFactor . y, uv . y * ditherFactor . z);
        outCol += fract(sin(dot(random01Range . xy, vec2(12.9898, 78.233)))* 43758.5453)* ditherFactor . x;
    }
}




void PostProcessColorConversionBlock(
    in uint postProcessFlags, in vec4 colorConversionFactor, in vec3 inCol, out vec3 outCol)
{
    outCol = inCol;
    if((postProcessFlags &(1 << 3))==
                                                       (1 << 3)){
        const uint conversionType = uint(colorConversionFactor . w);
        if(conversionType == 1){
            outCol . rgb = LinearToSrgb(outCol . rgb);
        }
    }
}




void PostProcessBloomCombineBlock(in uint postProcessFlags, in vec4 bloomFactor, in vec2 uv, in sampler2D imgSampler,
    in sampler2D dirtImgSampler, in vec3 inCol, out vec3 outCol)
{
    outCol = inCol;
    if((postProcessFlags &(1 << 9))==(1 << 9)){

        const vec3 bloomColor = textureLod(imgSampler, uv, 0). rgb * bloomFactor . z;
        const vec3 dirtColor = textureLod(dirtImgSampler, uv, 0). rgb * bloomFactor . w;
        const vec3 bloomCombine = outCol + bloomColor + dirtColor * max(bloomColor . x, max(bloomColor . y, bloomColor . z));
        outCol . rgb = min(bloomCombine, 64512.0);
    }
}


#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/Lume_3D/api/3d/shaders/common/3d_dm_inplace_post_process.h"





void InplacePostProcess(in vec2 fragUv, inout vec4 color)
{

    PostProcessTonemapBlock(
        uPostProcessData . flags . x, uPostProcessData . factors[0], color . rgb, color . rgb);

    const float tickDelta = uPostProcessData . renderTimings . y;
    const vec2 vecCoeffs = fragUv . xy * tickDelta;
    PostProcessDitherBlock(
        uPostProcessData . flags . x, uPostProcessData . factors[2], vecCoeffs, color . rgb, color . rgb);
    PostProcessVignetteBlock(
        uPostProcessData . flags . x, uPostProcessData . factors[1], fragUv, color . rgb, color . rgb);
    PostProcessColorConversionBlock(
        uPostProcessData . flags . x, uPostProcessData . factors[3], color . rgb, color . rgb);
}




#line 32 "shader/core3d_dm_fullscreen_env.frag"



layout(location = 0)in vec2 inUv;
layout(location = 1)in flat uint inIndices;

layout(location = 0)out vec4 outColor;
layout(location = 1)out vec4 outVelocityNormal;




void main(void)
{
    outColor = vec4(0.0, 0.0, 0.0, 1.0);

    const uint cameraIdx = GetUnpackFlatIndicesCameraIdx(inIndices);
    InplaceEnvironmentBlock(CORE_DEFAULT_ENV_TYPE, cameraIdx, inUv, uImgCubeSampler, uImgSampler, outColor);


    if(CORE_POST_PROCESS_FLAGS > 0){
        vec2 fragUv;
                                                                                                  (fragUv = GetFragCoordUv(gl_FragCoord . xy, uGeneralData . viewportSizeInvViewportSize . zw));

        InplacePostProcess(fragUv, outColor);
    }


    outVelocityNormal = GetPackVelocityAndNormal(vec2(0.0), vec3(0.0));
}
