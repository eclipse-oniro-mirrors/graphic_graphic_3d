














#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/assets/render/shaders/common/bloom_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"






































precision highp float;
precision highp int;





layout(constant_id = 256)const uint CORE_BACKEND_TYPE = 0;




layout(constant_id = 257)const float CORE_FLIP_NDC = 1.0;










vec2 GetFragCoordUv(vec2 fragCoord, vec2 inverseTexelSize)
{
    vec2 uv = fragCoord * inverseTexelSize;
    if(CORE_FLIP_NDC < 0.0){
        uv = vec2(uv . x, 1.0 - uv . y);
    }
    return uv;
}







#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/assets/render/shaders/common/bloom_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"






















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 24 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"




float CalcLuma(const vec3 color)
{

    return 0.299 * color . r + 0.587 * color . g + 0.114 * color . b;
}




float CalcLumaFxaa(const vec3 color)
{

    return color . g *(0.587 / 0.299)+ color . r;
}




float LumaWeight(const float luma)
{
    return(1.0 /(1.0 + luma));
}




vec3 TonemapLuma(const vec3 color, const float luma, const float range)
{
    return color /(1.0 + luma / range);
}




vec3 TonemapLumaInv(const vec3 color, const float luma, const float range)
{
    return color /(1.0 - luma / range);
}





vec3 SrgbToLinear(const vec3 srgb)
{
    const float mlow = 1.0f / 12.92f;
    const float mhigh = 1.0f / 1.055f;

    const vec3 high = pow((srgb + 0.055f)* mhigh, vec3(2.4f));
    const vec3 low = srgb * mlow;
    const bvec3 cutoff = lessThan(srgb, vec3(0.04045f));
    return mix(high, low, cutoff);
}





vec3 LinearToSrgb(const vec3 linear)
{
    const float mlow = 12.92f;
    const float mhigh = 1.055f;

    const vec3 high = pow(linear, vec3(0.416f))* mhigh - 0.055f;
    const vec3 low = linear * mlow;
    const bvec3 cutoff = lessThan(linear, vec3(0.0031308f));
    return mix(high, low, cutoff);
}





vec3 rgbToYCoCg(const vec3 rgb)
{
    const float y = dot(rgb, vec3(0.25, 0.5, 0.25));
    const float co = dot(rgb, vec3(0.5, 0.0, - 0.5));
    const float cg = dot(rgb, vec3(- 0.25, 0.5, - 0.25));
    return vec3(y, co, cg);
}





vec3 yCoCgToRgb(const vec3 ycocg)
{
    const float y = ycocg . r;
    const float co = ycocg . g;
    const float cg = ycocg . b;
    return vec3(y + co - cg, y + cg, y - co - cg);
}


#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/assets/render/shaders/common/bloom_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"






















































struct GlobalPostProcessStruct {

    uvec4 flags;

    vec4 renderTimings;


    vec4 factors[14];


    vec4 userFactors[16];
};




struct LocalPostProcessStruct {

    vec4 factors[16];
};

struct LocalPostProcessPushConstantStruct {

    vec4 viewportSizeInvSize;

    vec4 factor;
};

struct PostProcessTonemapStruct {
    vec4 texSizeInvTexSize;

    uvec4 flags;

    vec4 tonemap;
    vec4 vignette;
    vec4 colorFringe;
    vec4 dither;

    vec4 bloomParameters;
};


#line 22 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/assets/render/shaders/common/bloom_common.h"










vec3 bloomCombine(vec3 baseColor, vec3 bloomColor, vec4 bloomParameters)
{
    return baseColor + bloomColor * bloomParameters . z;
}







vec3 bloomDownscaleWeighted9(vec2 uv, vec2 invTexSize, texture2D tex, sampler sampl)
{
    vec3 colSample = textureLod(sampler2D(tex, sampl), uv + vec2(- 0.96875, 0.96875)* invTexSize, 0). xyz;
    float weight = 1.0 /(1.0 + CalcLuma(colSample));
    vec3 color = colSample *(8.0 / 128.0)* weight;
    float fullWeight = weight;

    colSample = textureLod(sampler2D(tex, sampl), uv + vec2(0.00000, 0.93750)* invTexSize, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(16.0 / 128.0)* weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), uv + vec2(0.96875, 0.96875)* invTexSize, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(8.0 / 128.0)* weight;
    fullWeight += weight;


    colSample = textureLod(sampler2D(tex, sampl), uv + vec2(- 0.93750, 0.00000)* invTexSize, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(16.0 / 128.0)* weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), uv, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(32.0 / 128.0)* weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), uv + vec2(0.93750, 0.00000)* invTexSize, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(16.0 / 128.0)* weight;
    fullWeight += weight;


    colSample = textureLod(sampler2D(tex, sampl), uv + vec2(- 0.96875, - 0.96875)* invTexSize, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(8.0 / 128.0)* weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), uv + vec2(0.00000, - 0.93750)* invTexSize, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(16.0 / 128.0)* weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), uv + vec2(0.96875, - 0.96875)* invTexSize, 0). xyz;
    weight = 1.0 /(1.0 + CalcLuma(colSample));
    color += colSample *(8.0 / 128.0)* weight;
    fullWeight += weight;







    color *= 10.5 /(fullWeight);

    return color;
}

vec3 bloomDownscale9(vec2 uv, vec2 invTexSize, texture2D tex, sampler sampl)
{
    vec3 color = textureLod(sampler2D(tex, sampl), uv + vec2(- invTexSize . x, invTexSize . y), 0). rgb *(8.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv + vec2(0.0, invTexSize . y), 0). rgb *(16.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv + invTexSize, 0). rgb *(8.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv + vec2(- invTexSize . x, 0.0), 0). rgb *(16.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv, 0). rgb *(32.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv + vec2(invTexSize . x, 0.0), 0). rgb *(16.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv - invTexSize, 0). rgb *(8.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv + vec2(0.0, - invTexSize . y), 0). rgb *(16.0 / 128.0);
    color += textureLod(sampler2D(tex, sampl), uv + vec2(invTexSize . x, - invTexSize . y), 0). rgb *(8.0 / 128.0);
    return color;
}

vec3 bloomDownscaleWeighted(vec2 uv, vec2 invTexSize, texture2D tex, sampler sampl)
{


    const float diagCoeff =(1.0f / 32.0f);
    const float stepCoeff =(2.0f / 32.0f);
    const float centerCoeff =(4.0f / 32.0f);

    const vec2 ts = invTexSize;

    float fullWeight = 0.00001;

    vec3 colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x - ts . x, uv . y - ts . y), 0). xyz;
    float weight = 1.0 /(1 + CalcLuma(colSample));
    vec3 color = colSample * diagCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x, uv . y - ts . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * stepCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x + ts . x, uv . y - ts . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * diagCoeff * weight;
    fullWeight += weight;


    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x - ts . x, uv . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * stepCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x, uv . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * centerCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x + ts . x, uv . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * stepCoeff * weight;
    fullWeight += weight;


    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x - ts . x, uv . y + ts . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * diagCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x, uv . y + ts . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * centerCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x + ts . x, uv . y + ts . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * diagCoeff * weight;
    fullWeight += weight;


    const vec2 ths = ts * 0.5;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x - ths . x, uv . y - ths . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * centerCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x + ths . x, uv . y - ths . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * centerCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x - ths . x, uv . y + ths . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * centerCoeff * weight;
    fullWeight += weight;

    colSample = textureLod(sampler2D(tex, sampl), vec2(uv . x + ths . x, uv . y + ths . y), 0). xyz;
    weight = 1.0 /(1 + CalcLuma(colSample));
    color += colSample * centerCoeff * weight;
    fullWeight += weight;







    color *=(13.0 / fullWeight);






































    return color;
}

vec3 bloomDownscale(vec2 uv, vec2 invTexSize, texture2D tex, sampler sampl)
{


    const float diagCoeff =(1.0f / 32.0f);
    const float stepCoeff =(2.0f / 32.0f);
    const float centerCoeff =(4.0f / 32.0f);

    const vec2 ts = invTexSize;

    vec3 color = textureLod(sampler2D(tex, sampl), vec2(uv . x - ts . x, uv . y - ts . y), 0). xyz * diagCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x, uv . y - ts . y), 0). xyz * stepCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x + ts . x, uv . y - ts . y), 0). xyz * diagCoeff;

    color += textureLod(sampler2D(tex, sampl), vec2(uv . x - ts . x, uv . y), 0). xyz * stepCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x, uv . y), 0). xyz * centerCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x + ts . x, uv . y), 0). xyz * stepCoeff;

    color += textureLod(sampler2D(tex, sampl), vec2(uv . x - ts . x, uv . y + ts . y), 0). xyz * diagCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x, uv . y + ts . y), 0). xyz * centerCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x + ts . x, uv . y + ts . y), 0). xyz * diagCoeff;


    const vec2 ths = ts * 0.5;

    color += textureLod(sampler2D(tex, sampl), vec2(uv . x - ths . x, uv . y - ths . y), 0). xyz * centerCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x + ths . x, uv . y - ths . y), 0). xyz * centerCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x - ths . x, uv . y + ths . y), 0). xyz * centerCoeff;
    color += textureLod(sampler2D(tex, sampl), vec2(uv . x + ths . x, uv . y + ths . y), 0). xyz * centerCoeff;
















    return color;
}




vec3 bloomUpscale(vec2 uv, vec2 invTexSize, texture2D tex, sampler sampl)
{
    const vec2 ts = invTexSize * 2.0;


    vec3 color = textureLod(sampler2D(tex, sampl), uv, 0). xyz *(1.0 / 2.0);

    color = textureLod(sampler2D(tex, sampl), uv - ts, 0). xyz
        *(1.0 / 8.0)+ color;
    color = textureLod(sampler2D(tex, sampl), uv + vec2(ts . x, - ts . y), 0). xyz
        *(1.0 / 8.0)+ color;
    color = textureLod(sampler2D(tex, sampl), uv + vec2(- ts . x, ts . y), 0). xyz
        *(1.0 / 8.0)+ color;
    color = textureLod(sampler2D(tex, sampl), uv + ts, 0). xyz
        *(1.0 / 8.0)+ color;

    return color;
}


#line 23 "computeshader/bloom_upscale.comp"



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"



















































































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"




layout(set = 0, binding = 0, std140)uniform uGlobalStructData
{
    GlobalPostProcessStruct uGlobalData;
};
layout(set = 0, binding = 1, std140)uniform uLocalStructData
{
    LocalPostProcessStruct uLocalData;
};

layout(push_constant, std430)uniform uPostProcessPushConstant
{
    LocalPostProcessPushConstantStruct uPc;
};

layout(constant_id = 0)const uint CORE_POST_PROCESS_FLAGS = 0;






#line 27 "computeshader/bloom_upscale.comp"

layout(set = 1, binding = 0, rgba16f)uniform readonly image2D uRTex;
layout(set = 1, binding = 0, rgba16f)uniform writeonly image2D uWTex;

layout(set = 1, binding = 1)uniform texture2D uTex;
layout(set = 1, binding = 2)uniform sampler uSampler;






layout(local_size_x = 8, local_size_y = 8, local_size_z = 1)in;
void main()
{

    const vec2 uv =(vec2(gl_GlobalInvocationID . xy)+ 0.5)* uPc . viewportSizeInvSize . zw;

    vec3 color = bloomUpscale(uv, uPc . viewportSizeInvSize . zw, uTex, uSampler);

    const ivec2 coords = ivec2(gl_GlobalInvocationID . xy);
    const vec3 baseColor = imageLoad(uRTex, coords). xyz;
    color = min((color + baseColor), 64512.0);
    imageStore(uWTex, coords, vec4(color, 1.0));
}
