














#version 460 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable




#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"






































precision highp float;
precision highp int;





layout(constant_id = 256)const uint CORE_BACKEND_TYPE = 0;




layout(constant_id = 257)const float CORE_FLIP_NDC = 1.0;










vec2 GetFragCoordUv(vec2 fragCoord, vec2 inverseTexelSize)
{
    vec2 uv = fragCoord * inverseTexelSize;
    if(CORE_FLIP_NDC < 0.0){
        uv = vec2(uv . x, 1.0 - uv . y);
    }
    return uv;
}







#line 24 "shader/fullscreen_blur.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_blur_common.h"



















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_blur_common.h"




























const float CORE_BLUR_OFFSETS[3]= { 0.0, 1.3846153846, 3.2307692308 };
const float CORE_BLUR_WEIGHTS[3]= { 0.2270270270, 0.3162162162, 0.0702702703 };

vec4 GaussianBlurRGBA(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    vec4 color = textureLod(sampler2D(tex, sampl), uv, 0)* CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dir . xy;

        color +=
            textureLod(sampler2D(tex, sampl),(vec2(fragCoord)+ currOffset)* invTexSize, 0)* CORE_BLUR_WEIGHTS[idx];
        color +=
            textureLod(sampler2D(tex, sampl),(vec2(fragCoord)- currOffset)* invTexSize, 0)* CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

vec3 GaussianBlurRGB(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    vec3 color = textureLod(sampler2D(tex, sampl), uv, 0). xyz * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dir . xy;

        color += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)+ currOffset)* invTexSize, 0). xyz *
                 CORE_BLUR_WEIGHTS[idx];
        color += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)- currOffset)* invTexSize, 0). xyz *
                 CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

vec2 GaussianBlurRG(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    vec2 color = textureLod(sampler2D(tex, sampl), uv, 0). xy * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dir . xy;

        color += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)+ currOffset)* invTexSize, 0). xy *
                 CORE_BLUR_WEIGHTS[idx];
        color += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)- currOffset)* invTexSize, 0). xy *
                 CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

float GaussianBlurR(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    float color = textureLod(sampler2D(tex, sampl), uv, 0). x * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dir . xy;

        color += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)+ currOffset)* invTexSize, 0). x *
                 CORE_BLUR_WEIGHTS[idx];
        color += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)- currOffset)* invTexSize, 0). x *
                 CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

float GaussianBlurA(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    float alpha = textureLod(sampler2D(tex, sampl), uv, 0). a * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dir . xy;

        alpha += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)+ currOffset, 0)* invTexSize, 0). a *
                 CORE_BLUR_WEIGHTS[idx];
        alpha += textureLod(sampler2D(tex, sampl),(vec2(fragCoord)- currOffset, 0)* invTexSize, 0). a *
                 CORE_BLUR_WEIGHTS[idx];
    }

    return alpha;
}

vec4 GaussianBlurRGBALayer(
    texture2DArray tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec3 dirLayer, const vec2 invTexSize)
{
    vec4 color = textureLod(sampler2DArray(tex, sampl), vec3(uv, dirLayer . z), 0)* CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dirLayer . xy;

        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)+ currOffset)* invTexSize, dirLayer . z), 0)*
            CORE_BLUR_WEIGHTS[idx];
        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)- currOffset)* invTexSize, dirLayer . z), 0)*
            CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

vec3 GaussianBlurRGBLayer(
    texture2DArray tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec3 dirLayer, const vec2 invTexSize)
{
    vec3 color = textureLod(sampler2DArray(tex, sampl), vec3(uv, dirLayer . z), 0). xyz * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dirLayer . xy;

        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)+ currOffset)* invTexSize, dirLayer . z), 0)
                . xyz *
            CORE_BLUR_WEIGHTS[idx];
        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)- currOffset)* invTexSize, dirLayer . z), 0)
                . xyz *
            CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

vec2 GaussianBlurRGLayer(
    texture2DArray tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec3 dirLayer, const vec2 invTexSize)
{
    vec2 color = textureLod(sampler2DArray(tex, sampl), vec3(uv, dirLayer . z), 0). xy * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dirLayer . xy;

        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)+ currOffset)* invTexSize, dirLayer . z), 0)
                . xy *
            CORE_BLUR_WEIGHTS[idx];
        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)- currOffset)* invTexSize, dirLayer . z), 0)
                . xy *
            CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

float GaussianBlurRLayer(
    texture2DArray tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec3 dirLayer, const vec2 invTexSize)
{
    float color = textureLod(sampler2DArray(tex, sampl), vec3(uv, dirLayer . z), 0). x * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dirLayer . xy;

        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)+ currOffset)* invTexSize, dirLayer . z), 0). x *
            CORE_BLUR_WEIGHTS[idx];
        color +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)- currOffset)* invTexSize, dirLayer . z), 0). x *
            CORE_BLUR_WEIGHTS[idx];
    }

    return color;
}

float GaussianBlurALayer(
    texture2DArray tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec3 dirLayer, const vec2 invTexSize)
{
    float alpha = textureLod(sampler2DArray(tex, sampl), vec3(uv, dirLayer . z), 0). a * CORE_BLUR_WEIGHTS[0];

    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dirLayer . xy;

        alpha +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)+ currOffset, 0)* invTexSize, dirLayer . z), 0)
                . a *
            CORE_BLUR_WEIGHTS[idx];
        alpha +=
            textureLod(sampler2DArray(tex, sampl), vec3((vec2(fragCoord)- currOffset, 0)* invTexSize, dirLayer . z), 0)
                . a *
            CORE_BLUR_WEIGHTS[idx];
    }

    return alpha;
}



vec3 SoftDownscaleRGB(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{































    const vec2 ths = invTexSize * 0.5;


    vec3 color = textureLod(sampler2D(tex, sampl), uv + ths, 0). xyz * 0.5;


    color = textureLod(sampler2D(tex, sampl), uv - ths, 0). xyz * 0.125 + color;
    color = textureLod(sampler2D(tex, sampl), vec2(uv . x + ths . x, uv . y - ths . y), 0). xyz * 0.125 + color;
    color = textureLod(sampler2D(tex, sampl), vec2(uv . x - ths . x, uv . y + ths . y), 0). xyz * 0.125 + color;
    color = textureLod(sampler2D(tex, sampl), uv + ths, 0). xyz * 0.125 + color;



    return color;
}

vec4 DownscaleRGBA(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    return textureLod(sampler2D(tex, sampl), uv, 0);
}

vec4 DownscaleRGBADof(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    const vec2 ths = invTexSize * 0.5;

    vec4 color = vec4(0);


    float weights[5]= { 0.5, 0.125, 0.125, 0.125, 0.125 };
    vec4 samples[5]= {

        textureLod(sampler2D(tex, sampl), uv, 0),

        textureLod(sampler2D(tex, sampl), uv - ths, 0),
        textureLod(sampler2D(tex, sampl), vec2(uv . x + ths . x, uv . y - ths . y), 0),
        textureLod(sampler2D(tex, sampl), vec2(uv . x - ths . x, uv . y + ths . y), 0),
        textureLod(sampler2D(tex, sampl), uv + ths, 0),
    };
    float weight = 0.0;
    for(int i = 0;i < 5;++ i){
        weight += samples[i]. a;
    }
    if(weight > 0.0){
        for(int i = 0;i < 5;++ i){
            color += samples[i]* weights[i];
        }
    } else {
        color = samples[0];
    }

    return color;
}

vec4 BlurRGBADof(
    texture2D tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec2 dir, const vec2 invTexSize)
{
    const vec2 ths = invTexSize * 0.5;

                mediump vec4 color = vec4(0);

                mediump vec4 samples[1 + 2 * 3];
    samples[0]= textureLod(sampler2D(tex, sampl), uv, 0);
    float weight = samples[0]. a;
    for(int idx = 1;idx < 3;++ idx){
        vec2 currOffset = vec2(CORE_BLUR_OFFSETS[idx])* dir . xy;

        samples[idx * 2 - 1]= textureLod(sampler2D(tex, sampl),(vec2(fragCoord)+ currOffset)* invTexSize, 0);
        weight += samples[idx * 2 - 1]. a;
        samples[idx * 2]= textureLod(sampler2D(tex, sampl),(vec2(fragCoord)- currOffset)* invTexSize, 0);
        weight += samples[idx * 2]. a;
    }
    if(weight > 0.0){
        weight = 1.0 / weight;
        color = samples[0]* CORE_BLUR_WEIGHTS[0]* weight;
        for(int idx = 1;idx < 3;++ idx){
            color += samples[idx * 2 - 1]* CORE_BLUR_WEIGHTS[idx]* weight;
            color += samples[idx * 2]* CORE_BLUR_WEIGHTS[idx]* weight;
        }
    } else {
        color = samples[0];
    }

    return color;
}

vec3 SoftDownscaleRGBLayer(
    texture2DArray tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec3 dirLayer, const vec2 invTexSize)
{































    const vec2 ths = invTexSize * 0.5;


    vec3 color = textureLod(sampler2DArray(tex, sampl), vec3(uv + ths, dirLayer . z), 0). xyz * 0.5;


    color = textureLod(sampler2DArray(tex, sampl), vec3(uv - ths, dirLayer . z), 0). xyz * 0.125 + color;
    color = textureLod(sampler2DArray(tex, sampl), vec3(uv . x + ths . x, uv . y - ths . y, dirLayer . z), 0). xyz * 0.125 + color;
    color = textureLod(sampler2DArray(tex, sampl), vec3(uv . x - ths . x, uv . y + ths . y, dirLayer . z), 0). xyz * 0.125 + color;
    color = textureLod(sampler2DArray(tex, sampl), vec3(uv + ths, dirLayer . z), 0). xyz * 0.125 + color;



    return color;
}

vec4 DownscaleRGBALayer(
    texture2DArray tex, sampler sampl, const vec2 fragCoord, const vec2 uv, const vec3 dirLayer, const vec2 invTexSize)
{
    return textureLod(sampler2DArray(tex, sampl), vec3(uv, dirLayer . z), 0);
}



#line 25 "shader/fullscreen_blur.frag"



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"






















































struct GlobalPostProcessStruct {

    uvec4 flags;

    vec4 renderTimings;


    vec4 factors[14];


    vec4 userFactors[16];
};




struct LocalPostProcessStruct {

    vec4 factors[16];
};

struct LocalPostProcessPushConstantStruct {

    vec4 viewportSizeInvSize;

    vec4 factor;
};

struct PostProcessTonemapStruct {
    vec4 texSizeInvTexSize;

    uvec4 flags;

    vec4 tonemap;
    vec4 vignette;
    vec4 colorFringe;
    vec4 dither;

    vec4 bloomParameters;
};


#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"




layout(set = 0, binding = 0, std140)uniform uGlobalStructData
{
    GlobalPostProcessStruct uGlobalData;
};
layout(set = 0, binding = 1, std140)uniform uLocalStructData
{
    LocalPostProcessStruct uLocalData;
};

layout(push_constant, std430)uniform uPostProcessPushConstant
{
    LocalPostProcessPushConstantStruct uPc;
};

layout(constant_id = 0)const uint CORE_POST_PROCESS_FLAGS = 0;






#line 29 "shader/fullscreen_blur.frag"

layout(set = 1, binding = 0)uniform sampler uSampler;
layout(set = 1, binding = 1)uniform texture2D uTex;



layout(location = 0)in vec2 inUv;

layout(location = 0)out vec4 outColor;

void main(void)
{
    if(CORE_POST_PROCESS_FLAGS == 1){
        outColor . r =
            GaussianBlurR(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). r;
    } else if(CORE_POST_PROCESS_FLAGS == 2){
        outColor . rg =
            GaussianBlurRG(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). rg;
    } else if(CORE_POST_PROCESS_FLAGS == 3){
        outColor . rgb =
            GaussianBlurRGB(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). rgb;
    } else if(CORE_POST_PROCESS_FLAGS == 4){
        outColor . r =
            GaussianBlurA(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). r;
    } else if(CORE_POST_PROCESS_FLAGS == 5){

        outColor . rgb =
            SoftDownscaleRGB(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). rgb;
    } else if(CORE_POST_PROCESS_FLAGS == 6){

        outColor . rgba =
            DownscaleRGBA(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). rgba;
    } else if(CORE_POST_PROCESS_FLAGS == 7){

        outColor . rgba =
            DownscaleRGBADof(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). rgba;
    } else if(CORE_POST_PROCESS_FLAGS == 0){
        outColor . rgba =
            GaussianBlurRGBA(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). rgba;
    } else if(CORE_POST_PROCESS_FLAGS == 8){

        outColor . rgba =
            DownscaleRGBADof(uTex, uSampler, gl_FragCoord . xy, inUv . xy, uPc . factor . xy, uPc . viewportSizeInvSize . zw). rgba;
    }
}
