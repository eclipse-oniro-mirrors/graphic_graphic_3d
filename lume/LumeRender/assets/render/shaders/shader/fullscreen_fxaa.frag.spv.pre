














#version 450 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"






















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"






































precision highp float;
precision highp int;





layout(constant_id = 256)const uint CORE_BACKEND_TYPE = 0;




layout(constant_id = 257)const float CORE_FLIP_NDC = 1.0;










vec2 GetFragCoordUv(vec2 fragCoord, vec2 inverseTexelSize)
{
    vec2 uv = fragCoord * inverseTexelSize;
    if(CORE_FLIP_NDC < 0.0){
        uv = vec2(uv . x, 1.0 - uv . y);
    }
    return uv;
}







#line 24 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"




float CalcLuma(const vec3 color)
{

    return 0.299 * color . r + 0.587 * color . g + 0.114 * color . b;
}




float CalcLumaFxaa(const vec3 color)
{

    return color . g *(0.587 / 0.299)+ color . r;
}




float LumaWeight(const float luma)
{
    return(1.0 /(1.0 + luma));
}




vec3 TonemapLuma(const vec3 color, const float luma, const float range)
{
    return color /(1.0 + luma / range);
}




vec3 TonemapLumaInv(const vec3 color, const float luma, const float range)
{
    return color /(1.0 - luma / range);
}





vec3 SrgbToLinear(const vec3 srgb)
{
    const float mlow = 1.0f / 12.92f;
    const float mhigh = 1.0f / 1.055f;

    const vec3 high = pow((srgb + 0.055f)* mhigh, vec3(2.4f));
    const vec3 low = srgb * mlow;
    const bvec3 cutoff = lessThan(srgb, vec3(0.04045f));
    return mix(high, low, cutoff);
}





vec3 LinearToSrgb(const vec3 linear)
{
    const float mlow = 12.92f;
    const float mhigh = 1.055f;

    const vec3 high = pow(linear, vec3(0.416f))* mhigh - 0.055f;
    const vec3 low = linear * mlow;
    const bvec3 cutoff = lessThan(linear, vec3(0.0031308f));
    return mix(high, low, cutoff);
}





vec3 rgbToYCoCg(const vec3 rgb)
{
    const float y = dot(rgb, vec3(0.25, 0.5, 0.25));
    const float co = dot(rgb, vec3(0.5, 0.0, - 0.5));
    const float cg = dot(rgb, vec3(- 0.25, 0.5, - 0.25));
    return vec3(y, co, cg);
}





vec3 yCoCgToRgb(const vec3 ycocg)
{
    const float y = ycocg . r;
    const float co = ycocg . g;
    const float cg = ycocg . b;
    return vec3(y + co - cg, y + cg, y - co - cg);
}


#line 23 "shader/fullscreen_fxaa.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"






















































struct GlobalPostProcessStruct {

    uvec4 flags;

    vec4 renderTimings;


    vec4 factors[14];


    vec4 userFactors[16];
};




struct LocalPostProcessStruct {

    vec4 factors[16];
};

struct LocalPostProcessPushConstantStruct {

    vec4 viewportSizeInvSize;

    vec4 factor;
};

struct PostProcessTonemapStruct {
    vec4 texSizeInvTexSize;

    uvec4 flags;

    vec4 tonemap;
    vec4 vignette;
    vec4 colorFringe;
    vec4 dither;

    vec4 bloomParameters;
};


#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"






float getVignetteCoeff(const vec2 uv, mediump const float coeff, mediump const float power)
{
    vec2 uvVal = uv . xy *(vec2(1.0)- uv . yx);
    float vignette = uvVal . x * uvVal . y * coeff;
    vignette = pow(vignette, power);
    return clamp(vignette, 0.0, 1.0);
}




float getChromaCoeff(const vec2 uv, mediump const float chromaCoefficient)
{

    vec2 distUv =(uv - 0.5)* 2.0;
    return dot(distUv, distUv)* chromaCoefficient;
}




float RandomDither(vec2 st)
{
    return fract(sin(dot(st . xy, vec2(12.9898, 78.233)))* 43758.5453);
}




#line 24 "shader/fullscreen_fxaa.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_tonemap_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"






















































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_tonemap_common.h"





vec3 TonemapAces(vec3 x)
{
    const float a = 2.51f;
    const float b = 0.03f;
    const float c = 2.43f;
    const float d = 0.59f;
    const float e = 0.14f;
    return(x *(a * x + b))/(x *(c * x + d)+ e);
}





vec3 TonemapAcesFilmRec2020(vec3 x)
{
    float a = 15.8f;
    float b = 2.12f;
    float c = 1.2f;
    float d = 5.92f;
    float e = 1.9f;
    return(x *(a * x + b))/(x *(c * x + d)+ e);
}





float TonemapFilmic(float x)
{
    const float a = 0.15f;
    const float b = 0.50f;
    const float c = 0.10f;
    const float d = 0.20f;
    const float e = 0.02f;
    const float f = 0.30f;
    return((x *(a * x + c * b)+ d * e)/(x *(a * x + b)+ d * f))- e / f;
}
vec3 TonemapFilmic(vec3 x)
{
    const float a = 0.15f;
    const float b = 0.50f;
    const float c = 0.10f;
    const float d = 0.20f;
    const float e = 0.02f;
    const float f = 0.30f;
    const float w = 11.2f;
    const vec3 curr =((x *(a * x + c * b)+ d * e)/(x *(a * x + b)+ d * f))- e / f;
    const float whiteScale = 1.0 / TonemapFilmic(w);
    return curr * vec3(whiteScale);
}


#line 25 "shader/fullscreen_fxaa.frag"





#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/assets/render/shaders/common/fxaa_reference.h"















































































































































































































































































































































































































































































































        float FxaaLuma(vec4 rgba){ return rgba . y;}















         vec4 FxaaPixelShader(

             vec2 pos,
             vec4 fxaaConsolePosPos,
          texture2D tex,
              sampler samp,


             vec2 fxaaQualityRcpFrame,
             vec4 fxaaConsoleRcpFrameOpt,
             vec4 fxaaConsoleRcpFrameOpt2,
             vec4 fxaaConsole360RcpFrameOpt2,
            float fxaaQualitySubpix,
            float fxaaQualityEdgeThreshold,
            float fxaaQualityEdgeThresholdMin,
            float fxaaConsoleEdgeSharpness,
            float fxaaConsoleEdgeThreshold,
            float fxaaConsoleEdgeThresholdMin,
             vec4 fxaaConsole360ConstDir
){

            float lumaNw = FxaaLuma(textureLod(sampler2D(tex, samp), fxaaConsolePosPos . xy, 0.0));
            float lumaSw = FxaaLuma(textureLod(sampler2D(tex, samp), fxaaConsolePosPos . xw, 0.0));
            float lumaNe = FxaaLuma(textureLod(sampler2D(tex, samp), fxaaConsolePosPos . zy, 0.0));
            float lumaSe = FxaaLuma(textureLod(sampler2D(tex, samp), fxaaConsolePosPos . zw, 0.0));


             vec4 rgbyM = textureLod(sampler2D(tex, samp), pos . xy, 0.0);



            float lumaM = rgbyM . y;



            float lumaMaxNwSw = max(lumaNw, lumaSw);






            float lumaMinNwSw = min(lumaNw, lumaSw);
            float lumaMaxNeSe = max(lumaNe, lumaSe);
            float lumaMinNeSe = min(lumaNe, lumaSe);
            float lumaMax = max(lumaMaxNeSe, lumaMaxNwSw);
            float lumaMin = min(lumaMinNeSe, lumaMinNwSw);
















            float lumaMaxScaled = lumaMax * fxaaConsoleEdgeThreshold;


            float lumaMinM = min(lumaMin, lumaM);
            float lumaMaxScaledClamped = max(fxaaConsoleEdgeThresholdMin, lumaMaxScaled);


            float lumaMaxM = max(lumaMax, lumaM);


            float dirSwMinusNe = lumaSw - lumaNe;

    dirSwMinusNe += 1.0 / 512.0;




            float lumaMaxSubMinM = lumaMaxM - lumaMinM;


            float dirSeMinusNw = lumaSe - lumaNw;


    if(lumaMaxSubMinM < lumaMaxScaledClamped){ return rgbyM;}


             vec2 dir;
    dir . x = dirSwMinusNe + dirSeMinusNw;
    dir . y = dirSwMinusNe - dirSeMinusNw;
             vec2 dir1 = normalize(dir . xy);


             vec4 rgbyN1 = textureLod(sampler2D(tex, samp), pos . xy - dir1 * fxaaConsoleRcpFrameOpt . zw, 0.0);
             vec4 rgbyP1 = textureLod(sampler2D(tex, samp), pos . xy + dir1 * fxaaConsoleRcpFrameOpt . zw, 0.0);




            float dirAbsMinTimesC = max(abs(dir1 . x), abs(dir1 . y))* fxaaConsoleEdgeSharpness * 0.015;
             vec2 dir2 = dir1 . xy * min(lumaMaxSubMinM / dirAbsMinTimesC, 3);




             vec4 rgbyN2 = textureLod(sampler2D(tex, samp), pos . xy - dir2 * fxaaConsoleRcpFrameOpt2 . zw, 0.0);
             vec4 rgbyP2 = textureLod(sampler2D(tex, samp), pos . xy + dir2 * fxaaConsoleRcpFrameOpt2 . zw, 0.0);


             vec4 rgbyA = rgbyN1 + rgbyP1;


             vec4 rgbyB =((rgbyN2 + rgbyP2)* 0.25)+(rgbyA * 0.25);








           bool twoTap =(rgbyB . y < lumaMin)||(rgbyB . y > lumaMax);

    if(twoTap){ rgbyB . xyz = rgbyA . xyz * 0.5;}






    rgbyB = mix(rgbyB, rgbyM, 0.25);

    return rgbyB;
}












































#line 31 "shader/fullscreen_fxaa.frag"



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"



















































































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"




layout(set = 0, binding = 0, std140)uniform uGlobalStructData
{
    GlobalPostProcessStruct uGlobalData;
};
layout(set = 0, binding = 1, std140)uniform uLocalStructData
{
    LocalPostProcessStruct uLocalData;
};

layout(push_constant, std430)uniform uPostProcessPushConstant
{
    LocalPostProcessPushConstantStruct uPc;
};

layout(constant_id = 0)const uint CORE_POST_PROCESS_FLAGS = 0;






#line 35 "shader/fullscreen_fxaa.frag"

layout(set = 1, binding = 0)uniform texture2D uTex;




layout(set = 1, binding = 1)uniform sampler uSampler;




layout(location = 0)in vec2 inUv;

layout(location = 0)out vec4 outColor;

float GetFxaaSharpness(const uint sharpness)
{

    if(sharpness == 0u){
        return 2.0f;
    } else if(sharpness == 1u){
        return 4.0f;
    } else {
        return 8.0f;
    }
}

vec2 GetFxaaThreshold(const uint quality)
{

    if(quality == 0u){
        return vec2(0.333f, 0.0833f);
    } else if(quality == 1u){
        return vec2(0.125f, 0.0312f);
    } else {
        return vec2(0.063f, 0.0625f);
    }
}

void main(void)
{
    const uint sharpness = uint(uPc . factor . x + 0.5f);
    const float fxaaSharpness = GetFxaaSharpness(sharpness);

    const uint quality = uint(uPc . factor . y + 0.5f);
    const vec2 fxaaThreshold = GetFxaaThreshold(quality);

    const vec2 textureSizeInv = uPc . viewportSizeInvSize . zw;
    const vec2 texelCenter = inUv;

    const vec4 aaPixel = FxaaPixelShader(texelCenter,
        vec4(texelCenter - textureSizeInv . xy * 0.5,
            texelCenter + textureSizeInv . xy * 0.5),
        uTex,
        uSampler,
        vec2(0),
        vec4(- textureSizeInv . xy, textureSizeInv . xy),
        2 * vec4(- textureSizeInv . xy, textureSizeInv . xy),
        vec4(0),
        0,

        0,

        0,

        fxaaSharpness,

        fxaaThreshold . x,

        fxaaThreshold . y,

        vec4(0)
    );






    outColor = aaPixel;

}
