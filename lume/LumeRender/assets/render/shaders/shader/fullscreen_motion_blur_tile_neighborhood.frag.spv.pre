














#version 450 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"






















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"






































precision highp float;
precision highp int;





layout(constant_id = 256)const uint CORE_BACKEND_TYPE = 0;




layout(constant_id = 257)const float CORE_FLIP_NDC = 1.0;










vec2 GetFragCoordUv(vec2 fragCoord, vec2 inverseTexelSize)
{
    vec2 uv = fragCoord * inverseTexelSize;
    if(CORE_FLIP_NDC < 0.0){
        uv = vec2(uv . x, 1.0 - uv . y);
    }
    return uv;
}







#line 24 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_color_conversion_common.h"




float CalcLuma(const vec3 color)
{

    return 0.299 * color . r + 0.587 * color . g + 0.114 * color . b;
}




float CalcLumaFxaa(const vec3 color)
{

    return color . g *(0.587 / 0.299)+ color . r;
}




float LumaWeight(const float luma)
{
    return(1.0 /(1.0 + luma));
}




vec3 TonemapLuma(const vec3 color, const float luma, const float range)
{
    return color /(1.0 + luma / range);
}




vec3 TonemapLumaInv(const vec3 color, const float luma, const float range)
{
    return color /(1.0 - luma / range);
}





vec3 SrgbToLinear(const vec3 srgb)
{
    const float mlow = 1.0f / 12.92f;
    const float mhigh = 1.0f / 1.055f;

    const vec3 high = pow((srgb + 0.055f)* mhigh, vec3(2.4f));
    const vec3 low = srgb * mlow;
    const bvec3 cutoff = lessThan(srgb, vec3(0.04045f));
    return mix(high, low, cutoff);
}





vec3 LinearToSrgb(const vec3 linear)
{
    const float mlow = 12.92f;
    const float mhigh = 1.055f;

    const vec3 high = pow(linear, vec3(0.416f))* mhigh - 0.055f;
    const vec3 low = linear * mlow;
    const bvec3 cutoff = lessThan(linear, vec3(0.0031308f));
    return mix(high, low, cutoff);
}





vec3 rgbToYCoCg(const vec3 rgb)
{
    const float y = dot(rgb, vec3(0.25, 0.5, 0.25));
    const float co = dot(rgb, vec3(0.5, 0.0, - 0.5));
    const float cg = dot(rgb, vec3(- 0.25, 0.5, - 0.25));
    return vec3(y, co, cg);
}





vec3 yCoCgToRgb(const vec3 ycocg)
{
    const float y = ycocg . r;
    const float co = ycocg . g;
    const float cg = ycocg . b;
    return vec3(y + co - cg, y + cg, y - co - cg);
}


#line 23 "shader/fullscreen_motion_blur_tile_neighborhood.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"






















































struct GlobalPostProcessStruct {

    uvec4 flags;

    vec4 renderTimings;


    vec4 factors[14];


    vec4 userFactors[16];
};




struct LocalPostProcessStruct {

    vec4 factors[16];
};

struct LocalPostProcessPushConstantStruct {

    vec4 viewportSizeInvSize;

    vec4 factor;
};

struct PostProcessTonemapStruct {
    vec4 texSizeInvTexSize;

    uvec4 flags;

    vec4 tonemap;
    vec4 vignette;
    vec4 colorFringe;
    vec4 dither;

    vec4 bloomParameters;
};


#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"






float getVignetteCoeff(const vec2 uv, mediump const float coeff, mediump const float power)
{
    vec2 uvVal = uv . xy *(vec2(1.0)- uv . yx);
    float vignette = uvVal . x * uvVal . y * coeff;
    vignette = pow(vignette, power);
    return clamp(vignette, 0.0, 1.0);
}




float getChromaCoeff(const vec2 uv, mediump const float chromaCoefficient)
{

    vec2 distUv =(uv - 0.5)* 2.0;
    return dot(distUv, distUv)* chromaCoefficient;
}




float RandomDither(vec2 st)
{
    return fract(sin(dot(st . xy, vec2(12.9898, 78.233)))* 43758.5453);
}




#line 24 "shader/fullscreen_motion_blur_tile_neighborhood.frag"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_tonemap_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_common.h"






















































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_tonemap_common.h"





vec3 TonemapAces(vec3 x)
{
    const float a = 2.51f;
    const float b = 0.03f;
    const float c = 2.43f;
    const float d = 0.59f;
    const float e = 0.14f;
    return(x *(a * x + b))/(x *(c * x + d)+ e);
}





vec3 TonemapAcesFilmRec2020(vec3 x)
{
    float a = 15.8f;
    float b = 2.12f;
    float c = 1.2f;
    float d = 5.92f;
    float e = 1.9f;
    return(x *(a * x + b))/(x *(c * x + d)+ e);
}





float TonemapFilmic(float x)
{
    const float a = 0.15f;
    const float b = 0.50f;
    const float c = 0.10f;
    const float d = 0.20f;
    const float e = 0.02f;
    const float f = 0.30f;
    return((x *(a * x + c * b)+ d * e)/(x *(a * x + b)+ d * f))- e / f;
}
vec3 TonemapFilmic(vec3 x)
{
    const float a = 0.15f;
    const float b = 0.50f;
    const float c = 0.10f;
    const float d = 0.20f;
    const float e = 0.02f;
    const float f = 0.30f;
    const float w = 11.2f;
    const vec3 curr =((x *(a * x + c * b)+ d * e)/(x *(a * x + b)+ d * f))- e / f;
    const float whiteScale = 1.0 / TonemapFilmic(w);
    return curr * vec3(whiteScale);
}


#line 25 "shader/fullscreen_motion_blur_tile_neighborhood.frag"



#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"


















#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_compatibility_common.h"












































































#line 20 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"
#line 1 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_structs_common.h"



















































































































#line 21 "/home/z00522378/workspace/OH_1210/foundation/graphic/graphic_3d/lume/LumeRender/api/render/shaders/common/render_post_process_layout_common.h"




layout(set = 0, binding = 0, std140)uniform uGlobalStructData
{
    GlobalPostProcessStruct uGlobalData;
};
layout(set = 0, binding = 1, std140)uniform uLocalStructData
{
    LocalPostProcessStruct uLocalData;
};

layout(push_constant, std430)uniform uPostProcessPushConstant
{
    LocalPostProcessPushConstantStruct uPc;
};

layout(constant_id = 0)const uint CORE_POST_PROCESS_FLAGS = 0;






#line 29 "shader/fullscreen_motion_blur_tile_neighborhood.frag"

layout(set = 1, binding = 0)uniform sampler2D uVelocity;



layout(location = 0)in vec2 inUv;

layout(location = 0)out vec4 outColor;







float SqrMagnitude(const vec2 vec)
{
    return vec . x * vec . x + vec . y * vec . y;
}

void GetMaxAround(const vec2 uv, out vec2 velocity)
{
    const uint sampleCount = 9;



    const ivec2 offsets[]= {
        ivec2(- 1, - 1),
        ivec2(0, - 1),
        ivec2(1, - 1),
        ivec2(- 1, 0),
        ivec2(0, 0),
        ivec2(1, 0),
        ivec2(- 1, 1),
        ivec2(0, 1),
        ivec2(1, 1),
    };
    vec2 velocities[sampleCount];
    velocities[0]= textureLodOffset(uVelocity, uv, 0, offsets[0]). xy;
    velocities[1]= textureLodOffset(uVelocity, uv, 0, offsets[1]). xy;
    velocities[2]= textureLodOffset(uVelocity, uv, 0, offsets[2]). xy;
    velocities[3]= textureLodOffset(uVelocity, uv, 0, offsets[3]). xy;
    velocities[4]= textureLodOffset(uVelocity, uv, 0, offsets[4]). xy;
    velocities[5]= textureLodOffset(uVelocity, uv, 0, offsets[5]). xy;
    velocities[6]= textureLodOffset(uVelocity, uv, 0, offsets[6]). xy;
    velocities[7]= textureLodOffset(uVelocity, uv, 0, offsets[7]). xy;
    velocities[8]= textureLodOffset(uVelocity, uv, 0, offsets[8]). xy;

    velocity = vec2(0.0);
    float sqrMagnitude = 0.0;
    for(uint idx = 0;idx < sampleCount;++ idx){
        const vec2 vel = velocities[idx];
        const float sqrMgn = SqrMagnitude(vel);
        if(sqrMgn > sqrMagnitude){
            velocity = vel;
            sqrMagnitude = sqrMgn;
        }
    }
}

void GetMaxHorizontal(const vec2 uv, out vec2 velocity)
{
    const uint sampleCount = 5;

    const ivec2 offsets[]= {
        ivec2(- 2, 0),
        ivec2(- 1, 0),
        ivec2(0, 0),
        ivec2(1, 0),
        ivec2(2, 0),
    };
    vec2 velocities[sampleCount];
    velocities[0]= textureLodOffset(uVelocity, uv, 0, offsets[0]). xy;
    velocities[1]= textureLodOffset(uVelocity, uv, 0, offsets[1]). xy;
    velocities[2]= textureLodOffset(uVelocity, uv, 0, offsets[2]). xy;
    velocities[3]= textureLodOffset(uVelocity, uv, 0, offsets[3]). xy;
    velocities[4]= textureLodOffset(uVelocity, uv, 0, offsets[4]). xy;

    velocity = vec2(0.0);
    float sqrMagnitude = 0.0;
    for(uint idx = 0;idx < sampleCount;++ idx){
        const vec2 vel = velocities[idx];
        const float sqrMgn = SqrMagnitude(vel);
        if(sqrMgn > sqrMagnitude){
            velocity = vel;
            sqrMagnitude = sqrMgn;
        }
    }
}

void GetMaxVertical(const vec2 uv, out vec2 velocity)
{
    const uint sampleCount = 5;

    const ivec2 offsets[]= {
        ivec2(0, - 2),
        ivec2(0, - 1),
        ivec2(0, 0),
        ivec2(0, 1),
        ivec2(0, 2),
    };
    vec2 velocities[sampleCount];
    velocities[0]= textureLodOffset(uVelocity, uv, 0, offsets[0]). xy;
    velocities[1]= textureLodOffset(uVelocity, uv, 0, offsets[1]). xy;
    velocities[2]= textureLodOffset(uVelocity, uv, 0, offsets[2]). xy;
    velocities[3]= textureLodOffset(uVelocity, uv, 0, offsets[3]). xy;
    velocities[4]= textureLodOffset(uVelocity, uv, 0, offsets[4]). xy;

    velocity = vec2(0.0);
    float sqrMagnitude = 0.0;
    for(uint idx = 0;idx < sampleCount;++ idx){
        const vec2 vel = velocities[idx];
        const float sqrMgn = SqrMagnitude(vel);
        if(sqrMgn > sqrMagnitude){
            velocity = vel;
            sqrMagnitude = sqrMgn;
        }
    }
}




void main(void)
{
    const vec2 uv = inUv . xy;

    vec2 velocity = vec2(0.0);
    if(CORE_POST_PROCESS_FLAGS == 1){
        GetMaxHorizontal(uv, velocity);
    } else if(CORE_POST_PROCESS_FLAGS == 2){
        GetMaxVertical(uv, velocity);
    } else {


        GetMaxAround(uv, velocity);
    }

    outColor = vec4(velocity, 0.0, 0.0);
}
