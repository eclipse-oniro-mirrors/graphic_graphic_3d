/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!sts_inject("""
import { ResourceStr } from 'arkui.component.units';
// Ensure that libscene_ani is loaded.
loadLibrary('scene_ani.z');

export interface Container<T> {
    append(item: T): void;
    insertAfter(item: T, sibling: T | null): void;
    remove(item: T): void;
    get(index: int): T | null;
    clear(): void;
    count(): int;
}

export class NodeContainerProxy implements Container<Node> {
    private nc: NodeContainer;
    constructor(nc: NodeContainer) {
        this.nc = nc;
    }

    append(item: Node): void {
        this.nc.append(item);
    }

    insertAfter(item: Node, sibling: Node | null): void {
        this.nc.insertAfter(item, sibling);
    }

    remove(item: Node): void {
        this.nc.remove(item);
    }

    get(index: int): Node | null {
        return this.nc.get(index);
    }

    clear(): void {
        this.nc.clear();
    }

    count(): int {
        return this.nc.count();
    }
}
""")

@!namespace("SceneNodes")

from SceneResources use SceneResource, Mesh, MeshResource, Morpher;
from SceneTypes use Quaternion, Color, RenderingPipelineType, Vec2, Vec3, Mat4x4;
from ScenePostProcessSettings use PostProcessSettings;
from SceneTH use RaycastParameters, RaycastResult, SceneNodeParameters;

interface LayerMask {
    getEnabled(index: i32): bool;

    setEnabled(index: i32, enabled: bool): void;
}

enum NodeType: i32 {
    NODE = 1,
    GEOMETRY = 2,
    CAMERA = 3,
    LIGHT = 4,
}

interface NodeContainer {
    append(item: Node): void;

    insertAfter(item: Node, sibling: NodeOrNull): void;

    remove(item: Node): void;

    get(index: i32): VariousNodesOrNull;

    clear(): void;

    count(): i32;
}

interface Node: SceneResource {
    @get getPosition(): Vec3;
    @set setPosition(pos: Vec3): void;

    @get getRotation(): Quaternion;
    @set setRotation(rotate: Quaternion): void;

    @get getScale(): Vec3;
    @set setScale(scale: Vec3): void;

    @get getVisible(): bool;
    @set setVisible(visible: bool): void;

    @get getNodeType(): NodeType;

    @get getLayerMask(): LayerMask;

    @get getPath(): String;

    @get getParent(): VariousNodesOrNull;

    @!sts_inject_into_interface("""
    get children(): Container<Node>;
    """)

    @!sts_inject_into_class("""
    get children(): Container<Node> {
        return new NodeContainerProxy(this.getNodeContainer()) as Container<Node>;
    }
    """)

    getNodeContainer(): NodeContainer;

    getNodeByPath(path: String): VariousNodesOrNull;
}

union NodeOrNull {
    node: Node;
    @null nValue;
}

union VariousNodesOrNull {
    geometry: Geometry;
    camera: Camera;
    light: Light;
    node: Node;
    @null nValue;
}

union VariousNodes {
    geometry: Geometry;
    camera: Camera;
    light: Light;
    node: Node;
}

interface Geometry : Node {
    @get getMesh(): Mesh;
    @get getMorpher(): Optional<Morpher>;

    @!sts_inject_into_class("""
    get children(): Container<Node> {
        return new NodeContainerProxy(this.getNodeContainer()) as Container<Node>;
    }
    """)
}

enum LightType: i32 {
    DIRECTIONAL = 1,
    SPOT = 2,
}

interface Light: Node {
    @get getLightType(): LightType;

    @get getColor(): Color;
    @set setColor(color: Color): void;

    @get getIntensity(): f64;
    @set setIntensity(intensity: f64): void;

    @get getShadowEnabled(): bool;
    @set setShadowEnabled(enabled: bool): void;

    @get getEnabled(): bool;
    @set setEnabled(enable: bool): void;

    @get getInnerAngle(): Optional<f64>;
    @set setInnerAngle(innerAngle: Optional<f64>): void;

    @get getOuterAngle(): Optional<f64>;
    @set setOuterAngle(outerAngle: Optional<f64>): void;

    @get getRange(): Optional<f64>;
    @set setRange(range: Optional<f64>): void;

    @!sts_inject_into_class("""
    get children(): Container<Node> {
        return new NodeContainerProxy(this.getNodeContainer()) as Container<Node>;
    }
    """)
}

interface SpotLight: Light {
    @!sts_inject_into_class("""
    get children(): Container<Node> {
        return new NodeContainerProxy(this.getNodeContainer()) as Container<Node>;
    }
    """)
}

interface DirectionalLight: Light {
    @!sts_inject_into_class("""
    get children(): Container<Node> {
        return new NodeContainerProxy(this.getNodeContainer()) as Container<Node>;
    }
    """)
}

union LightTypeUnion {
    directional: DirectionalLight;
    spot: SpotLight;
    base: Light;
}

union PostProcessSettingsOrNull {
    postProcess: PostProcessSettings;
    @null nValue;
}

union ColorOrNull {
    color: Color;
    @null nValue;
}

interface Camera: Node {
    @get getFov(): f64;
    @set setFov(fov: f64): void;

    @get getNearPlane(): f64;
    @set setNearPlane(nearPlane: f64): void;

    @get getFarPlane(): f64;
    @set setFarPlane(farPlane: f64): void;

    @get getEnabled(): bool;
    @set setEnabled(enabled: bool): void;

    @get getPostProcess(): PostProcessSettingsOrNull;
    @set setPostProcess(process: PostProcessSettingsOrNull): void;

    @get getClearColor(): ColorOrNull;
    @set setClearColor(color: ColorOrNull): void;

    @get getMsaa(): Optional<bool>;
    @set setMsaa(msaa: Optional<bool>): void;

    @get getRenderingPipeline(): Optional<RenderingPipelineType>;
    @set setRenderingPipeline(renderingPipeline: Optional<RenderingPipelineType>): void;

    @gen_promise("raycast")
    raycastSync(viewPosition: Vec2, params: RaycastParameters): Array<RaycastResult>;

    worldToScreen(worldPosition: Vec3): Vec3;
    screenToWorld(viewPosition: Vec3): Vec3;

    getViewMatrix(): Mat4x4;
    getProjectionMatrix(): Mat4x4;

    @!sts_inject_into_class("""
    get children(): Container<Node> {
        return new NodeContainerProxy(this.getNodeContainer()) as Container<Node>;
    }
    """)
}