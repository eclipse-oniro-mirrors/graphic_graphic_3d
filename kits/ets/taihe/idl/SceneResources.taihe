/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!sts_inject("""
import { ResourceStr } from 'arkui.component.units';
import { RecordIterator } from './RecordProxy';
import { Callback } from '@ohos.base';
// Ensure that libscene_ani is loaded.
loadLibrary('scene_ani.z');

class ShaderRecord extends Record<string, ShaderInputType> {
    private shader: Shader;

    constructor(shader: Shader) {
        this.shader = shader;
    }

    override get size(): int {
        return this.shader.getInputsSize();
    }

    override get(k: string, def: ShaderInputType): ShaderInputType {
        return this.shader.getInput(k) ?? def;
    }

    override get(k: string): ShaderInputType | undefined {
        return this.shader.getInput(k);
    }

    override set(k: string, v: ShaderInputType): this {
        this.shader.setInput(k, v);
        return this;
    }

    override $_get(key: string): ShaderInputType | undefined {
        return this.shader.getInput(key);
    }

    override $_set(key: string, value: ShaderInputType): void {
        this.shader.setInput(key, value);
    }

    override keys(): IterableIterator<string> {
        return new RecordIterator<string>(this.shader.getInputsKeys(), (key: string) => key);
    }

    override values(): IterableIterator<ShaderInputType> {
        return new RecordIterator<ShaderInputType>(this.shader.getInputsKeys(), (key: string) => this.shader.getInput(key)!);
    }

    override entries(): IterableIterator<[string, ShaderInputType]> {
        return new RecordIterator<[string, ShaderInputType]>(this.shader.getInputsKeys(),
            (key: string) => [key, this.shader.getInput(key)!]);
    }
}

class MorpherRecord extends Record<string, double> {
    private morpher: Morpher;

    constructor(morpher: Morpher) {
        this.morpher = morpher;
    }

    override get size(): int {
        return this.morpher.getTargetsSize();
    }

    override get(k: string, def: double): double {
        return this.morpher.getTarget(k) ?? def;
    }

    override get(k: string): double | undefined {
        return this.morpher.getTarget(k);
    }

    override set(k: string, v: double): this {
        this.morpher.setTarget(k, v);
        return this;
    }

    override $_get(key: string): double | undefined {
        return this.morpher.getTarget(key);
    }

    override $_set(key: string, value: double): void {
        this.morpher.setTarget(key, value);
    }

    override keys(): IterableIterator<string> {
        return new RecordIterator<string>(this.morpher.getTargetsKeys(), (key: string) => key);
    }

    override values(): IterableIterator<double> {
        return new RecordIterator<double>(this.morpher.getTargetsKeys(), (key: string) => this.morpher.getTarget(key)!);
    }

    override entries(): IterableIterator<[string, double]> {
        return new RecordIterator<[string, double]>(this.morpher.getTargetsKeys(),
            (key: string) => [key, this.morpher.getTarget(key)!]);
    }
}
""")

@!namespace("SceneResources")

from SceneTypes use Vec2, Vec3, Vec4, Aabb, GeometryDefinition, GeometryDefinitionType, Quaternion;
from SceneTH use SceneResourceParameters;

enum SceneResourceType: i32 {
    UNKNOWN = 0,
    NODE = 1,
    ENVIRONMENT = 2,
    MATERIAL = 3,
    MESH = 4,
    ANIMATION = 5,
    SHADER = 6,
    IMAGE = 7,
    MESH_RESOURCE = 8,
}

interface SceneResource {
    @get getName(): String;
    @set setName(name: String): void;

    @get getResourceType(): SceneResourceType;

    @get getUri(): Optional<@sts_type("ResourceStr") Opaque>;

    destroy(): void;

    @get getImpl(): Optional<i64>;
}

enum MaterialType: i32 {
    SHADER = 1,
    METALLIC_ROUGHNESS = 2,
    UNLIT = 3,
}

enum CullMode: i32 {
    NONE = 0,
    FRONT = 1,
    BACK = 2,
}

enum PolygonMode: i32 {
    FILL = 0,
    LINE = 1,
    POINT = 2,
}

struct Blend {
    enabled: bool;
}

struct RenderSort {
    renderSortLayer: Optional<i32>;
    renderSortLayerOrder: Optional<i32>;
}

interface Material : SceneResource {
    @get getMaterialType(): MaterialType;

    @get getShadowReceiver(): Optional<bool>;
    @set setShadowReceiver(value: Optional<bool>): void;

    @get getCullMode(): Optional<CullMode>;
    @set setCullMode(mode: Optional<CullMode>): void;

    @get getPolygonMode(): Optional<PolygonMode>;
    @set setPolygonMode(mode: Optional<PolygonMode>): void;

    @get getBlend(): Optional<Blend>;
    @set setBlend(blend: Optional<Blend>): void;

    @get getAlphaCutoff(): Optional<f64>;
    @set setAlphaCutoff(cutoff: Optional<f64>): void;

    @get getRenderSort(): Optional<RenderSort>;
    @set setRenderSort(renderSort: Optional<RenderSort>): void;
}

enum SamplerFilter: i32 {
    NEAREST = 0,
    LINEAR = 1,
}

enum SamplerAddressMode: i32 {
    REPEAT = 0,
    MIRRORED_REPEAT = 1,
    CLAMP_TO_EDGE = 2,
}

interface Sampler {
    @get getMagFilter(): Optional<SamplerFilter>;
    @set setMagFilter(filter: Optional<SamplerFilter>): void;

    @get getMinFilter(): Optional<SamplerFilter>;
    @set setMinFilter(filter: Optional<SamplerFilter>): void;

    @get getMipMapMode(): Optional<SamplerFilter>;
    @set setMipMapMode(mode: Optional<SamplerFilter>): void;

    @get getAddressModeU(): Optional<SamplerAddressMode>;
    @set setAddressModeU(mode: Optional<SamplerAddressMode>): void;

    @get getAddressModeV(): Optional<SamplerAddressMode>;
    @set setAddressModeV(mode: Optional<SamplerAddressMode>): void;

    @get getImpl(): Optional<i64>;
}

union ImageOrNull {
    image: Image;
    @null nValue;
}

union ImageOrNullOrUndefined {
    @undefined uValue;
    @null nValue;
    image: Image;
}

interface MaterialProperty {
    @get getImage(): ImageOrNull;
    @set setImage(img: ImageOrNull): void;

    @get getFactor(): Vec4;
    @set setFactor(factor: Vec4): void;

    @get getSampler(): Optional<Sampler>;
    @set setSampler(sampler: Optional<Sampler>): void;

    @get getImpl(): Optional<i64>;
}

interface MetallicRoughnessMaterial : Material {
    @get getBaseColor(): MaterialProperty;
    @set setBaseColor(color: MaterialProperty): void;

    @get getNormal(): MaterialProperty;
    @set setNormal(normal: MaterialProperty): void;

    @get getMaterial(): MaterialProperty;
    @set setMaterial(material: MaterialProperty): void;

    @get getAmbientOcclusion(): MaterialProperty;
    @set setAmbientOcclusion(ao: MaterialProperty): void;

    @get getEmissive(): MaterialProperty;
    @set setEmissive(emissive: MaterialProperty): void;

    @get getClearCoat(): MaterialProperty;
    @set setClearCoat(clearCoat: MaterialProperty): void;

    @get getClearCoatRoughness(): MaterialProperty;
    @set setClearCoatRoughness(roughness: MaterialProperty): void;

    @get getClearCoatNormal(): MaterialProperty;
    @set setClearCoatNormal(normal: MaterialProperty): void;

    @get getSheen(): MaterialProperty;
    @set setSheen(sheen: MaterialProperty): void;

    @get getSpecular(): MaterialProperty;
    @set setSpecular(specular: MaterialProperty): void;
}

interface ShaderMaterial : Material {
    @get getColorShader(): Optional<Shader>;
    @set setColorShader(shader: Optional<Shader>): void;
}

interface UnlitMaterial : Material {
    @!sts_inject_into_interface("""
    get baseColor(): MaterialProperty;
    set baseColor(color: MaterialProperty);
    """)

    @!sts_inject_into_class("""
    get baseColor(): MaterialProperty {
        return this.getBaseColorInner();
    }
    set baseColor(color: MaterialProperty) {
        this.setBaseColorInner(color);
    }
    """)

    getBaseColorInner(): MaterialProperty;
    setBaseColorInner(color: MaterialProperty): void;
}

interface PBRMaterial: MetallicRoughnessMaterial, ShaderMaterial, UnlitMaterial {
}

union VariousMaterial {
    pbr: PBRMaterial;
    shader: ShaderMaterial;
    metaRough: MetallicRoughnessMaterial;
    base: Material;
}

interface SubMesh {
    @get getName(): String;
    @set setName(name: String): void;

    @get getMaterial(): VariousMaterial;
    @set setMaterial(mat: Material): void;

    @get getAabb(): Aabb;
}

interface Morpher {
    @!sts_inject_into_interface("""
    get targets(): Record<string, double>;
    """)

    @!sts_inject_into_class("""
    get targets(): MorpherRecord {
        return new MorpherRecord(this);
    }
    """)

    getTargetsSize(): i32;
    getTargetsKeys(): Array<String>;
    getTarget(key: String): Optional<f64>;
    setTarget(key: String, value: f64): void;
}

interface Mesh : SceneResource {
    @get getSubMeshes(): Array<SubMesh>;
    @get getAabb(): Aabb;

    @get getMaterialOverride(): Optional<VariousMaterial>;
    @set setMaterialOverride(mat: Optional<Material>): void;
}

interface MeshResource : SceneResource {
}

union CallbackUndefinedType {
    @undefined undefined;
}

interface Animation : SceneResource {
    @get getEnabled(): bool;
    @set setEnabled(enabled: bool): void;

    @get getSpeed(): Optional<f64>;
    @set setSpeed(speed: Optional<f64>): void;

    @get getDuration(): f64;

    @get getRunning(): bool;

    @get getProgress(): f64;

    @!sts_inject_into_interface("""
    onFinished(callback: Callback<void>): void;
    """)

    @!sts_inject_into_class("""
    onFinished(callback: Callback<void>): void {
        this.onFinishedInner(() => {
            EAWorker.postToMain<void>(callback);
        });
    }
    """)

    onFinishedInner(callback: () => void): void;

    onStarted(callback: (data: CallbackUndefinedType) => void): void;

    pause(): void;

    restart(): void;

    seek(position: f64): void;

    start(): void;

    stop(): void;

    finish(): void;

    getAnimationImpl(): i64;
}

enum EnvironmentBackgroundType : i32 {
    BACKGROUND_NONE = 0,
    BACKGROUND_IMAGE = 1,
    BACKGROUND_CUBEMAP = 2,
    BACKGROUND_EQUIRECTANGULAR = 3,
}

interface Environment : SceneResource {
    @get getBackgroundType(): EnvironmentBackgroundType;
    @set setBackgroundType(type: EnvironmentBackgroundType): void;

    @get getIndirectDiffuseFactor(): Vec4;
    @set setIndirectDiffuseFactor(factor: Vec4): void;

    @get getIndirectSpecularFactor(): Vec4;
    @set setIndirectSpecularFactor(factor: Vec4): void;

    @get getEnvironmentMapFactor(): Vec4;
    @set setEnvironmentMapFactor(factor: Vec4): void;

    @get getEnvironmentImage(): ImageOrNullOrUndefined;
    @set setEnvironmentImage(image: ImageOrNullOrUndefined): void;

    @get getRadianceImage(): ImageOrNullOrUndefined;
    @set setRadianceImage(image: ImageOrNullOrUndefined): void;

    @get getIrradianceCoefficients(): Optional<Array<Vec3>>;
    @set setIrradianceCoefficients(coefficients: Optional<Array<Vec3>>): void;

    @get getEnvironmentRotation(): Optional<Quaternion>;
    @set setEnvironmentRotation(rotation: Optional<Quaternion>): void;
}

interface Image : SceneResource {
    @get getWidth(): i32;
    @get getHeight(): i32;
}

union ShaderInputType {
    t_i32: i32;
    t_f64: f64;
    t_vec2: Vec2;
    t_vec3: Vec3;
    t_vec4: Vec4;
    t_image: Image;
}

interface Shader : SceneResource {
    @!sts_inject_into_interface("""
    get inputs(): Record<string, ShaderInputType>;
    """)

    @!sts_inject_into_class("""
    get inputs(): ShaderRecord {
        return new ShaderRecord(this);
    }
    """)

    getInputsSize(): i32;
    getInputsKeys(): Array<String>;
    getInput(key: String): Optional<ShaderInputType>;
    setInput(key: String, value: ShaderInputType): void;
}